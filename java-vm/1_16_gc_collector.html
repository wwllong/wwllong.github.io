<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>垃圾收集器 | 万隆的笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.png">
    <script>var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?d8c4de0636e24ecd74e706a345ab8cc9";
              var s = document.getElementsByTagName("script")[0]; 
              s.parentNode.insertBefore(hm, s);
            })();</script>
    <meta name="description" content="小小码农">
    
    <link rel="preload" href="/assets/css/0.styles.e68661c4.css" as="style"><link rel="preload" href="/assets/js/app.bc037eca.js" as="script"><link rel="preload" href="/assets/js/3.a3373ef9.js" as="script"><link rel="preload" href="/assets/js/166.be1e5538.js" as="script"><link rel="prefetch" href="/assets/js/10.4df5c055.js"><link rel="prefetch" href="/assets/js/100.0d629d95.js"><link rel="prefetch" href="/assets/js/101.2db02bf9.js"><link rel="prefetch" href="/assets/js/102.d68c24bb.js"><link rel="prefetch" href="/assets/js/103.600018bb.js"><link rel="prefetch" href="/assets/js/104.c413414c.js"><link rel="prefetch" href="/assets/js/105.8c15211b.js"><link rel="prefetch" href="/assets/js/106.84e8ee9b.js"><link rel="prefetch" href="/assets/js/107.a9e7f4b2.js"><link rel="prefetch" href="/assets/js/108.f3285402.js"><link rel="prefetch" href="/assets/js/109.8cf78ec2.js"><link rel="prefetch" href="/assets/js/11.5acc5c3a.js"><link rel="prefetch" href="/assets/js/110.1822bed3.js"><link rel="prefetch" href="/assets/js/111.a9157b2f.js"><link rel="prefetch" href="/assets/js/112.f9617caf.js"><link rel="prefetch" href="/assets/js/113.2cf20d85.js"><link rel="prefetch" href="/assets/js/114.690001dc.js"><link rel="prefetch" href="/assets/js/115.01270cf8.js"><link rel="prefetch" href="/assets/js/116.f58bd27d.js"><link rel="prefetch" href="/assets/js/117.a7d22187.js"><link rel="prefetch" href="/assets/js/118.9b13fb7e.js"><link rel="prefetch" href="/assets/js/119.e56d4413.js"><link rel="prefetch" href="/assets/js/12.944e78c3.js"><link rel="prefetch" href="/assets/js/120.6a373e09.js"><link rel="prefetch" href="/assets/js/121.f05c8ac8.js"><link rel="prefetch" href="/assets/js/122.b23768d7.js"><link rel="prefetch" href="/assets/js/123.274a1455.js"><link rel="prefetch" href="/assets/js/124.1672408d.js"><link rel="prefetch" href="/assets/js/125.7fb88ab5.js"><link rel="prefetch" href="/assets/js/126.5db859c8.js"><link rel="prefetch" href="/assets/js/127.a34ecf8a.js"><link rel="prefetch" href="/assets/js/128.54e15d3c.js"><link rel="prefetch" href="/assets/js/129.6e2cae17.js"><link rel="prefetch" href="/assets/js/13.1d4ba2e8.js"><link rel="prefetch" href="/assets/js/130.6ad457a8.js"><link rel="prefetch" href="/assets/js/131.aeedef23.js"><link rel="prefetch" href="/assets/js/132.443d76bf.js"><link rel="prefetch" href="/assets/js/133.641d77af.js"><link rel="prefetch" href="/assets/js/134.1824a48c.js"><link rel="prefetch" href="/assets/js/135.bf659059.js"><link rel="prefetch" href="/assets/js/136.185d1de5.js"><link rel="prefetch" href="/assets/js/137.5bcb50d7.js"><link rel="prefetch" href="/assets/js/138.5b56d765.js"><link rel="prefetch" href="/assets/js/139.4f07d83f.js"><link rel="prefetch" href="/assets/js/14.78c03a65.js"><link rel="prefetch" href="/assets/js/140.b14458e8.js"><link rel="prefetch" href="/assets/js/141.16eba01d.js"><link rel="prefetch" href="/assets/js/142.67697a4e.js"><link rel="prefetch" href="/assets/js/143.b1ee0e16.js"><link rel="prefetch" href="/assets/js/144.9800e31a.js"><link rel="prefetch" href="/assets/js/145.cdd7e47e.js"><link rel="prefetch" href="/assets/js/146.4d8b9cf6.js"><link rel="prefetch" href="/assets/js/147.1ce23cab.js"><link rel="prefetch" href="/assets/js/148.854fb1e4.js"><link rel="prefetch" href="/assets/js/149.da169cf3.js"><link rel="prefetch" href="/assets/js/15.a60df2b4.js"><link rel="prefetch" href="/assets/js/150.b3d06f97.js"><link rel="prefetch" href="/assets/js/151.16f22697.js"><link rel="prefetch" href="/assets/js/152.e39ae535.js"><link rel="prefetch" href="/assets/js/153.81ecd116.js"><link rel="prefetch" href="/assets/js/154.cbc5938f.js"><link rel="prefetch" href="/assets/js/155.00385d0c.js"><link rel="prefetch" href="/assets/js/156.4517568a.js"><link rel="prefetch" href="/assets/js/157.f1433c46.js"><link rel="prefetch" href="/assets/js/158.5352cd07.js"><link rel="prefetch" href="/assets/js/159.c4f81687.js"><link rel="prefetch" href="/assets/js/16.da7f7410.js"><link rel="prefetch" href="/assets/js/160.3778e817.js"><link rel="prefetch" href="/assets/js/161.4ecebe00.js"><link rel="prefetch" href="/assets/js/162.261c214f.js"><link rel="prefetch" href="/assets/js/163.e7abb47f.js"><link rel="prefetch" href="/assets/js/164.570dd314.js"><link rel="prefetch" href="/assets/js/165.f904d36e.js"><link rel="prefetch" href="/assets/js/167.eca75917.js"><link rel="prefetch" href="/assets/js/168.5ede7a24.js"><link rel="prefetch" href="/assets/js/169.8f030b14.js"><link rel="prefetch" href="/assets/js/17.ba9ee66f.js"><link rel="prefetch" href="/assets/js/170.5b3d76ad.js"><link rel="prefetch" href="/assets/js/171.d6534d74.js"><link rel="prefetch" href="/assets/js/172.8cfd94b9.js"><link rel="prefetch" href="/assets/js/173.fb4f0904.js"><link rel="prefetch" href="/assets/js/174.7dba6bb9.js"><link rel="prefetch" href="/assets/js/175.c6c8980d.js"><link rel="prefetch" href="/assets/js/176.5c8bee1e.js"><link rel="prefetch" href="/assets/js/177.7d9b6b50.js"><link rel="prefetch" href="/assets/js/178.9b0f6d6b.js"><link rel="prefetch" href="/assets/js/179.851f4874.js"><link rel="prefetch" href="/assets/js/18.68e82e56.js"><link rel="prefetch" href="/assets/js/180.d4946561.js"><link rel="prefetch" href="/assets/js/181.dddb9217.js"><link rel="prefetch" href="/assets/js/182.179b516a.js"><link rel="prefetch" href="/assets/js/183.f6c78374.js"><link rel="prefetch" href="/assets/js/184.1dde444f.js"><link rel="prefetch" href="/assets/js/185.3db3afc3.js"><link rel="prefetch" href="/assets/js/186.2c0f07eb.js"><link rel="prefetch" href="/assets/js/187.5f6f57ff.js"><link rel="prefetch" href="/assets/js/188.97586f9f.js"><link rel="prefetch" href="/assets/js/189.8a39dde2.js"><link rel="prefetch" href="/assets/js/19.9aa6dcce.js"><link rel="prefetch" href="/assets/js/190.96731259.js"><link rel="prefetch" href="/assets/js/191.d096d222.js"><link rel="prefetch" href="/assets/js/192.a921d348.js"><link rel="prefetch" href="/assets/js/193.a3e07c61.js"><link rel="prefetch" href="/assets/js/194.8934403d.js"><link rel="prefetch" href="/assets/js/195.13b302ff.js"><link rel="prefetch" href="/assets/js/196.4ad81cf9.js"><link rel="prefetch" href="/assets/js/197.8a23e1be.js"><link rel="prefetch" href="/assets/js/198.a1bf2bc3.js"><link rel="prefetch" href="/assets/js/199.c6abf07d.js"><link rel="prefetch" href="/assets/js/2.98bbb7f5.js"><link rel="prefetch" href="/assets/js/20.513c8e9b.js"><link rel="prefetch" href="/assets/js/200.f5a2f491.js"><link rel="prefetch" href="/assets/js/201.03671056.js"><link rel="prefetch" href="/assets/js/202.f94ec544.js"><link rel="prefetch" href="/assets/js/203.2a09fec0.js"><link rel="prefetch" href="/assets/js/204.e56dddcb.js"><link rel="prefetch" href="/assets/js/205.f48c8602.js"><link rel="prefetch" href="/assets/js/206.a8d9bcc4.js"><link rel="prefetch" href="/assets/js/207.e4016538.js"><link rel="prefetch" href="/assets/js/208.be8af315.js"><link rel="prefetch" href="/assets/js/209.4cfde3a6.js"><link rel="prefetch" href="/assets/js/21.1e72e195.js"><link rel="prefetch" href="/assets/js/210.f4936cb6.js"><link rel="prefetch" href="/assets/js/211.063bdacd.js"><link rel="prefetch" href="/assets/js/212.353d50f2.js"><link rel="prefetch" href="/assets/js/213.094a5cfc.js"><link rel="prefetch" href="/assets/js/214.d16aa2d2.js"><link rel="prefetch" href="/assets/js/215.bc88e375.js"><link rel="prefetch" href="/assets/js/216.45511649.js"><link rel="prefetch" href="/assets/js/217.99946f6f.js"><link rel="prefetch" href="/assets/js/218.43a39089.js"><link rel="prefetch" href="/assets/js/219.d14424be.js"><link rel="prefetch" href="/assets/js/22.324c39b4.js"><link rel="prefetch" href="/assets/js/220.882e9a86.js"><link rel="prefetch" href="/assets/js/221.40e3d13e.js"><link rel="prefetch" href="/assets/js/222.23004b98.js"><link rel="prefetch" href="/assets/js/223.5130614a.js"><link rel="prefetch" href="/assets/js/224.2a560c15.js"><link rel="prefetch" href="/assets/js/225.92cc9d19.js"><link rel="prefetch" href="/assets/js/226.38630a69.js"><link rel="prefetch" href="/assets/js/227.ddd1a6d3.js"><link rel="prefetch" href="/assets/js/228.2d4cf247.js"><link rel="prefetch" href="/assets/js/229.458c49c4.js"><link rel="prefetch" href="/assets/js/23.beabd1c9.js"><link rel="prefetch" href="/assets/js/230.1530afe6.js"><link rel="prefetch" href="/assets/js/231.26875105.js"><link rel="prefetch" href="/assets/js/232.3c906b6a.js"><link rel="prefetch" href="/assets/js/233.d633d2c5.js"><link rel="prefetch" href="/assets/js/234.841291f0.js"><link rel="prefetch" href="/assets/js/235.de892702.js"><link rel="prefetch" href="/assets/js/236.a0ff8c56.js"><link rel="prefetch" href="/assets/js/237.bbc7b6ef.js"><link rel="prefetch" href="/assets/js/238.b53d8e52.js"><link rel="prefetch" href="/assets/js/239.ae488c24.js"><link rel="prefetch" href="/assets/js/24.a2f1a1cf.js"><link rel="prefetch" href="/assets/js/240.06d1aa99.js"><link rel="prefetch" href="/assets/js/241.e782f534.js"><link rel="prefetch" href="/assets/js/242.cae48a9d.js"><link rel="prefetch" href="/assets/js/243.4eea58f3.js"><link rel="prefetch" href="/assets/js/244.b3cfbb67.js"><link rel="prefetch" href="/assets/js/245.734f2b40.js"><link rel="prefetch" href="/assets/js/246.83ba6a01.js"><link rel="prefetch" href="/assets/js/247.bee3fa17.js"><link rel="prefetch" href="/assets/js/248.633a3a01.js"><link rel="prefetch" href="/assets/js/249.cbcc1465.js"><link rel="prefetch" href="/assets/js/25.1598a580.js"><link rel="prefetch" href="/assets/js/250.7b21393b.js"><link rel="prefetch" href="/assets/js/251.2fb1b244.js"><link rel="prefetch" href="/assets/js/252.c0e95582.js"><link rel="prefetch" href="/assets/js/253.42d96179.js"><link rel="prefetch" href="/assets/js/254.2f556423.js"><link rel="prefetch" href="/assets/js/255.5c518629.js"><link rel="prefetch" href="/assets/js/256.6c37f138.js"><link rel="prefetch" href="/assets/js/257.bfaf2b90.js"><link rel="prefetch" href="/assets/js/258.501c8dec.js"><link rel="prefetch" href="/assets/js/259.433c5a35.js"><link rel="prefetch" href="/assets/js/26.14532494.js"><link rel="prefetch" href="/assets/js/260.7133674c.js"><link rel="prefetch" href="/assets/js/261.7c497a98.js"><link rel="prefetch" href="/assets/js/262.ef906292.js"><link rel="prefetch" href="/assets/js/263.7b1b901f.js"><link rel="prefetch" href="/assets/js/264.36ebfc79.js"><link rel="prefetch" href="/assets/js/265.33897322.js"><link rel="prefetch" href="/assets/js/266.8670f739.js"><link rel="prefetch" href="/assets/js/267.ec8f4c6a.js"><link rel="prefetch" href="/assets/js/268.487e3ecf.js"><link rel="prefetch" href="/assets/js/269.dd269c27.js"><link rel="prefetch" href="/assets/js/27.182ae611.js"><link rel="prefetch" href="/assets/js/270.bfc37c9e.js"><link rel="prefetch" href="/assets/js/271.b1193de2.js"><link rel="prefetch" href="/assets/js/272.4d22dbda.js"><link rel="prefetch" href="/assets/js/273.f76b57ca.js"><link rel="prefetch" href="/assets/js/274.8aa70460.js"><link rel="prefetch" href="/assets/js/275.f8a4d784.js"><link rel="prefetch" href="/assets/js/276.73193b56.js"><link rel="prefetch" href="/assets/js/277.eb11f3ab.js"><link rel="prefetch" href="/assets/js/278.bbbd0f67.js"><link rel="prefetch" href="/assets/js/279.0d5be41f.js"><link rel="prefetch" href="/assets/js/28.cc74fb69.js"><link rel="prefetch" href="/assets/js/280.e937fced.js"><link rel="prefetch" href="/assets/js/281.3e4a2290.js"><link rel="prefetch" href="/assets/js/282.927224e7.js"><link rel="prefetch" href="/assets/js/283.11981dd7.js"><link rel="prefetch" href="/assets/js/284.f51d8c6d.js"><link rel="prefetch" href="/assets/js/285.36e1d9fd.js"><link rel="prefetch" href="/assets/js/286.6ae62cc1.js"><link rel="prefetch" href="/assets/js/287.83708e55.js"><link rel="prefetch" href="/assets/js/288.bae95807.js"><link rel="prefetch" href="/assets/js/289.96cf6017.js"><link rel="prefetch" href="/assets/js/29.e3df47e0.js"><link rel="prefetch" href="/assets/js/290.c8bbd938.js"><link rel="prefetch" href="/assets/js/291.ee2a4137.js"><link rel="prefetch" href="/assets/js/292.37a36b48.js"><link rel="prefetch" href="/assets/js/293.6589f01f.js"><link rel="prefetch" href="/assets/js/294.9e2c7ac2.js"><link rel="prefetch" href="/assets/js/295.54f91c63.js"><link rel="prefetch" href="/assets/js/296.437948b8.js"><link rel="prefetch" href="/assets/js/297.77b67b30.js"><link rel="prefetch" href="/assets/js/298.847026f8.js"><link rel="prefetch" href="/assets/js/299.f7987fa5.js"><link rel="prefetch" href="/assets/js/30.d956a42b.js"><link rel="prefetch" href="/assets/js/300.fb926d10.js"><link rel="prefetch" href="/assets/js/301.39be1acb.js"><link rel="prefetch" href="/assets/js/302.0d4b2462.js"><link rel="prefetch" href="/assets/js/303.797685f0.js"><link rel="prefetch" href="/assets/js/304.953dd6d8.js"><link rel="prefetch" href="/assets/js/305.45a68780.js"><link rel="prefetch" href="/assets/js/306.9436c9f7.js"><link rel="prefetch" href="/assets/js/307.c8da713f.js"><link rel="prefetch" href="/assets/js/308.42164c3a.js"><link rel="prefetch" href="/assets/js/309.08138204.js"><link rel="prefetch" href="/assets/js/31.b08efb45.js"><link rel="prefetch" href="/assets/js/310.3bdab8a3.js"><link rel="prefetch" href="/assets/js/311.6cb6bc2c.js"><link rel="prefetch" href="/assets/js/312.b2211997.js"><link rel="prefetch" href="/assets/js/313.27e5d88b.js"><link rel="prefetch" href="/assets/js/314.4345463c.js"><link rel="prefetch" href="/assets/js/315.cfd666b9.js"><link rel="prefetch" href="/assets/js/316.744f1ea3.js"><link rel="prefetch" href="/assets/js/317.0a990397.js"><link rel="prefetch" href="/assets/js/318.49bfe4f7.js"><link rel="prefetch" href="/assets/js/319.0e9f0404.js"><link rel="prefetch" href="/assets/js/32.42eb6c80.js"><link rel="prefetch" href="/assets/js/320.95c40fa6.js"><link rel="prefetch" href="/assets/js/321.d3557402.js"><link rel="prefetch" href="/assets/js/322.381f65d0.js"><link rel="prefetch" href="/assets/js/323.883198dc.js"><link rel="prefetch" href="/assets/js/324.cad6119f.js"><link rel="prefetch" href="/assets/js/325.90509c04.js"><link rel="prefetch" href="/assets/js/33.cba29bcc.js"><link rel="prefetch" href="/assets/js/34.60629bfe.js"><link rel="prefetch" href="/assets/js/35.a60b566c.js"><link rel="prefetch" href="/assets/js/36.099489dc.js"><link rel="prefetch" href="/assets/js/37.a40ed816.js"><link rel="prefetch" href="/assets/js/38.7e946531.js"><link rel="prefetch" href="/assets/js/39.1e9449ed.js"><link rel="prefetch" href="/assets/js/4.0893bcb9.js"><link rel="prefetch" href="/assets/js/40.a68e55dd.js"><link rel="prefetch" href="/assets/js/41.c2410ec6.js"><link rel="prefetch" href="/assets/js/42.6059e0a0.js"><link rel="prefetch" href="/assets/js/43.666eab60.js"><link rel="prefetch" href="/assets/js/44.6d2bc28e.js"><link rel="prefetch" href="/assets/js/45.23095742.js"><link rel="prefetch" href="/assets/js/46.2c644d05.js"><link rel="prefetch" href="/assets/js/47.0c53d023.js"><link rel="prefetch" href="/assets/js/48.6763315e.js"><link rel="prefetch" href="/assets/js/49.5df08a8b.js"><link rel="prefetch" href="/assets/js/5.0c8b00ed.js"><link rel="prefetch" href="/assets/js/50.21bed711.js"><link rel="prefetch" href="/assets/js/51.cc283ef4.js"><link rel="prefetch" href="/assets/js/52.448e1e19.js"><link rel="prefetch" href="/assets/js/53.8d139bfe.js"><link rel="prefetch" href="/assets/js/54.ab823596.js"><link rel="prefetch" href="/assets/js/55.28d6b882.js"><link rel="prefetch" href="/assets/js/56.799dfc32.js"><link rel="prefetch" href="/assets/js/57.47844017.js"><link rel="prefetch" href="/assets/js/58.a3636228.js"><link rel="prefetch" href="/assets/js/59.b88e34c1.js"><link rel="prefetch" href="/assets/js/6.a436075e.js"><link rel="prefetch" href="/assets/js/60.08d9b769.js"><link rel="prefetch" href="/assets/js/61.62eaaae6.js"><link rel="prefetch" href="/assets/js/62.2e8a878d.js"><link rel="prefetch" href="/assets/js/63.498c3cfe.js"><link rel="prefetch" href="/assets/js/64.32bf8090.js"><link rel="prefetch" href="/assets/js/65.0f690d46.js"><link rel="prefetch" href="/assets/js/66.90352622.js"><link rel="prefetch" href="/assets/js/67.480bdaa6.js"><link rel="prefetch" href="/assets/js/68.9979d713.js"><link rel="prefetch" href="/assets/js/69.780f4d95.js"><link rel="prefetch" href="/assets/js/7.4d9f4e60.js"><link rel="prefetch" href="/assets/js/70.c2ca172c.js"><link rel="prefetch" href="/assets/js/71.ae3f1c72.js"><link rel="prefetch" href="/assets/js/72.93cde0ad.js"><link rel="prefetch" href="/assets/js/73.8ee7e6cc.js"><link rel="prefetch" href="/assets/js/74.cde76b4d.js"><link rel="prefetch" href="/assets/js/75.1f2c3f1d.js"><link rel="prefetch" href="/assets/js/76.960c7d73.js"><link rel="prefetch" href="/assets/js/77.9d4b9659.js"><link rel="prefetch" href="/assets/js/78.310cf545.js"><link rel="prefetch" href="/assets/js/79.bd667333.js"><link rel="prefetch" href="/assets/js/8.7541ba14.js"><link rel="prefetch" href="/assets/js/80.f42edee8.js"><link rel="prefetch" href="/assets/js/81.dda99508.js"><link rel="prefetch" href="/assets/js/82.ec338e99.js"><link rel="prefetch" href="/assets/js/83.66b1f5b4.js"><link rel="prefetch" href="/assets/js/84.2173e568.js"><link rel="prefetch" href="/assets/js/85.3b5e4e47.js"><link rel="prefetch" href="/assets/js/86.3c179528.js"><link rel="prefetch" href="/assets/js/87.28691828.js"><link rel="prefetch" href="/assets/js/88.5830058a.js"><link rel="prefetch" href="/assets/js/89.2e630253.js"><link rel="prefetch" href="/assets/js/9.038ee2be.js"><link rel="prefetch" href="/assets/js/90.05aa65c3.js"><link rel="prefetch" href="/assets/js/91.99ac4500.js"><link rel="prefetch" href="/assets/js/92.f1bd8f70.js"><link rel="prefetch" href="/assets/js/93.f35f7adf.js"><link rel="prefetch" href="/assets/js/94.f6780083.js"><link rel="prefetch" href="/assets/js/95.be362a29.js"><link rel="prefetch" href="/assets/js/96.f8368d2d.js"><link rel="prefetch" href="/assets/js/97.745204bf.js"><link rel="prefetch" href="/assets/js/98.58c8fcaa.js"><link rel="prefetch" href="/assets/js/99.d4d25887.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e68661c4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/favicon.png" alt="万隆的笔记" class="logo"> <span class="site-name can-hide">万隆的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes-guide/" class="nav-link">
  博文索引
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="在线资源" class="dropdown-title"><span class="title">在线资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="在线资源" class="mobile-dropdown-title"><span class="title">在线资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          在线学站
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.runoob.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  菜鸟教程
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.w3cschool.cn/tutorial" target="_blank" rel="noopener noreferrer" class="nav-link external">
  入门教程
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.coursera.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Coursera
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          在线文档
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.w3school.com.cn/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  w3school
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.bootcss.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Bootstrap
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          在线工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://tool.lu/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  tool 工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.bejson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  bejson 工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://smallpdf.com/cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文档转换
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><!----> <a href="/online/" class="nav-link">
  更多在线资源
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/change-logs/" class="nav-link">
  Changlog
</a></li><li class="dropdown-item"><!----> <a href="/more/about-me.html" class="nav-link">
  Aboutme
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wwllong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes-guide/" class="nav-link">
  博文索引
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="在线资源" class="dropdown-title"><span class="title">在线资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="在线资源" class="mobile-dropdown-title"><span class="title">在线资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          在线学站
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.runoob.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  菜鸟教程
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.w3cschool.cn/tutorial" target="_blank" rel="noopener noreferrer" class="nav-link external">
  入门教程
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.coursera.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Coursera
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          在线文档
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://www.w3school.com.cn/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  w3school
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.bootcss.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Bootstrap
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          在线工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://tool.lu/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  tool 工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.bejson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  bejson 工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://smallpdf.com/cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文档转换
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><!----> <a href="/online/" class="nav-link">
  更多在线资源
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/change-logs/" class="nav-link">
  Changlog
</a></li><li class="dropdown-item"><!----> <a href="/more/about-me.html" class="nav-link">
  Aboutme
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wwllong" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java虚拟机</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/" aria-current="page" class="sidebar-link">大纲</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>走近Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/0_1_foreword.html" class="sidebar-link">JVM前言</a></li><li><a href="/java-vm/0_2_java_jvm_introd.html" class="sidebar-link">Java与JVM简介</a></li><li><a href="/java-vm/0_3_jvm_framework.html" class="sidebar-link">JVM架构模型</a></li><li><a href="/java-vm/0_4_jvm_life_cycle.html" class="sidebar-link">JVM生命周期</a></li><li><a href="/java-vm/0_5_java_histroy.html" class="sidebar-link">Java的发展重大事件</a></li><li><a href="/java-vm/0_6_jvm_family.html" class="sidebar-link">JVM家族</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>内存与垃圾回收</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/1_1_memory_structure.html" class="sidebar-link">JVM内存结构图</a></li><li><a href="/java-vm/1_2_class_loading_sys.html" class="sidebar-link">类加载器子系统</a></li><li><a href="/java-vm/1_3_runtime_data_area_ov.html" class="sidebar-link">运行时数据区</a></li><li><a href="/java-vm/1_4_pc_register.html" class="sidebar-link">程序计数器（PC寄存器）</a></li><li><a href="/java-vm/1_5_vm_statck.html" class="sidebar-link">虚拟机栈</a></li><li><a href="/java-vm/1_6_native_method_stack.html" class="sidebar-link">本地方法栈</a></li><li><a href="/java-vm/1_7_heap.html" class="sidebar-link">堆</a></li><li><a href="/java-vm/1_8_methods_area.html" class="sidebar-link">方法区</a></li><li><a href="/java-vm/1_8_1_methods_area.html" class="sidebar-link">- 方法区使用举例图解</a></li><li><a href="/java-vm/1_9_new_object.html" class="sidebar-link">对象的实例化</a></li><li><a href="/java-vm/1_10_direct_memory.html" class="sidebar-link">直接内存</a></li><li><a href="/java-vm/1_11_execution_engine.html" class="sidebar-link">执行引擎</a></li><li><a href="/java-vm/1_12_string_table.html" class="sidebar-link">String Table</a></li><li><a href="/java-vm/1_13_gc_introd.html" class="sidebar-link">垃圾回收概述</a></li><li><a href="/java-vm/1_14_gc_concept.html" class="sidebar-link">垃圾回收相关概念</a></li><li><a href="/java-vm/1_15_gc_algs.html" class="sidebar-link">垃圾回收算法</a></li><li><a href="/java-vm/1_16_gc_collector.html" aria-current="page" class="active sidebar-link">垃圾收集器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#垃圾收集器" class="sidebar-link">垃圾收集器</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#垃圾收集器分类" class="sidebar-link">垃圾收集器分类</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#垃圾收集器性能指标" class="sidebar-link">垃圾收集器性能指标</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#吞吐量" class="sidebar-link">吞吐量</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#暂停时间" class="sidebar-link">暂停时间</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#吞吐量-vs-暂停时间" class="sidebar-link">吞吐量 vs 暂停时间</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#不同垃圾回收器概述" class="sidebar-link">不同垃圾回收器概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#垃圾回收器发展史" class="sidebar-link">垃圾回收器发展史</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#_7种经典的垃圾收集器" class="sidebar-link">7种经典的垃圾收集器</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#经典收集器与垃圾分代之间的关系" class="sidebar-link">经典收集器与垃圾分代之间的关系</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#经典收集器的组合关系" class="sidebar-link">经典收集器的组合关系</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#不同的垃圾收集器概述" class="sidebar-link">不同的垃圾收集器概述</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#如何查看默认垃圾收集器" class="sidebar-link">如何查看默认垃圾收集器</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#serial回收器-串行回收" class="sidebar-link">Serial回收器：串行回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#执行过程" class="sidebar-link">执行过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#参数" class="sidebar-link">参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#parnew回收器-并行回收" class="sidebar-link">ParNew回收器：并行回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#执行过程-2" class="sidebar-link">执行过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#参数-2" class="sidebar-link">参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#parallel回收器-吞吐量优先" class="sidebar-link">Parallel回收器：吞吐量优先</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#执行过程-3" class="sidebar-link">执行过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#参数-3" class="sidebar-link">参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#cms回收器-低延迟" class="sidebar-link">CMS回收器：低延迟</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#执行过程-4" class="sidebar-link">执行过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#优缺点" class="sidebar-link">优缺点</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#参数-4" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#jdk后续版本中cms的变化" class="sidebar-link">JDK后续版本中CMS的变化</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收器-区域化分代式" class="sidebar-link">G1回收器：区域化分代式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1简介与名称由来" class="sidebar-link">G1简介与名称由来</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#特点-优势" class="sidebar-link">特点（优势）</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#参数-5" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#常见操作步骤" class="sidebar-link">常见操作步骤</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#适用场景" class="sidebar-link">适用场景</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#分区region-化整为零" class="sidebar-link">分区Region：化整为零</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1的回收过程" class="sidebar-link">G1的回收过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#remembered-set" class="sidebar-link">Remembered Set</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收过程一-年轻代gc" class="sidebar-link">G1回收过程一：年轻代GC</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收过程二-并发标记过程" class="sidebar-link">G1回收过程二：并发标记过程</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收过程三-混合回收" class="sidebar-link">G1回收过程三：混合回收</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收可选的过程四-full-gc" class="sidebar-link">G1回收可选的过程四：Full GC</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#g1回收器优化建议" class="sidebar-link">G1回收器优化建议</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#_7种经典垃圾回收器总结" class="sidebar-link">7种经典垃圾回收器总结</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#垃圾回收器组合" class="sidebar-link">垃圾回收器组合</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#怎么选择垃圾回收器" class="sidebar-link">怎么选择垃圾回收器</a></li></ul></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#新发展" class="sidebar-link">新发展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#jdk-11-新特性" class="sidebar-link">JDK 11 新特性</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#openjdk-12的shenandoash-gc" class="sidebar-link">OpenJDK 12的Shenandoash GC</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#令人震惊、革命性的zgc" class="sidebar-link">令人震惊、革命性的ZGC</a></li><li class="sidebar-sub-header"><a href="/java-vm/1_16_gc_collector.html#其他垃圾回收器-aligc" class="sidebar-link">其他垃圾回收器：AliGC</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>字节码与类加载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/2_1_class_sys_introd.html" class="sidebar-link">JVM基石：class文件</a></li><li><a href="/java-vm/2_2_class_file_struct.html" class="sidebar-link">class文件结构</a></li><li><a href="/java-vm/2_2_1_class_file_javap.html" class="sidebar-link">javap解析class文件</a></li><li><a href="/java-vm/2_3_bytecode_instruction_set.html" class="sidebar-link">字节码指令集</a></li><li><a href="/java-vm/2_4_class_loading_process.html" class="sidebar-link">类加载过程（类生命周期）</a></li><li><a href="/java-vm/2_5_class_loader.html" class="sidebar-link">再谈类的加载器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>性能监控与调优</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/3_1_tuning_introd.html" class="sidebar-link">概述</a></li><li><a href="/java-vm/3_2_tuning_command.html" class="sidebar-link">JVM监控及诊断工具-命令行篇</a></li><li><a href="/java-vm/3_3_tuning_gui.html" class="sidebar-link">JVM监控及诊断工具-GUI篇</a></li><li><a href="/java-vm/3_4_tuning_vmparam.html" class="sidebar-link">JVM运行时参数</a></li><li><a href="/java-vm/1_17_gc_log.html" class="sidebar-link">GC日志分析</a></li><li><a href="/java-vm/3_6_tuning_heap_shallow_retained.html" class="sidebar-link">浅堆深堆与支配树</a></li><li><a href="/java-vm/3_8_tuning_heap_leak_overflow.html" class="sidebar-link">内存泄漏与内存溢出</a></li><li><a href="/java-vm/3_7_tuning_qql.html" class="sidebar-link">QQL语言查询对象信息</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>监控与性能调优案例</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-vm/3_tuning_case0_introd.html" class="sidebar-link">概述</a></li><li><a href="/java-vm/3_tuning_case0_tomcat_hoom.html" class="sidebar-link">Tomcat堆溢出分析</a></li><li><a href="/java-vm/3_tuning_case1_heap_oom.html" class="sidebar-link">堆溢出</a></li><li><a href="/java-vm/3_tuning_case2_method_oom.html" class="sidebar-link">方法区溢出</a></li><li><a href="/java-vm/3_tuning_case3_limit_exceeded.html" class="sidebar-link">GC overhead limit exceeded</a></li><li><a href="/java-vm/3_tuning_case4_thread_oom.html" class="sidebar-link">线程溢出</a></li><li><a href="/java-vm/3_tuning_perf_case1_tps.html" class="sidebar-link">调整堆大小提高服务的吞吐量</a></li><li><a href="/java-vm/3_tuning_perf_case2_jit.html" class="sidebar-link">JVM优化之JIT优化</a></li><li><a href="/java-vm/3_tuning_perf_case3_heapsize.html" class="sidebar-link">合理配置堆内存</a></li><li><a href="/java-vm/3_tuning_perf_case4_cpu_hight.html" class="sidebar-link">CPU占用很高排查方案</a></li><li><a href="/java-vm/3_tuning_perf_case5_g1.html" class="sidebar-link">G1并发执行的线程数对性能的影响</a></li><li><a href="/java-vm/3_tuning_perf_case6_gcc.html" class="sidebar-link">调整垃圾回收器提高服务的吞吐量</a></li><li><a href="/java-vm/3_tuning_perf_case7_millions4orders.html" class="sidebar-link">日均百万级订单交易系统如何设置JVM参数</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="垃圾收集器"><a href="#垃圾收集器" class="header-anchor">#</a> 垃圾收集器</h2> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>垃圾收集器（Garbage Collector）没有在JVM规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p> <p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p> <p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p> <h2 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="header-anchor">#</a> 垃圾收集器分类</h2> <ol><li>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。</li></ol> <ul><li>串行垃圾回收器：指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停（STW），直至垃圾收集工作结束。
<ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的<code>Client</code>模式下的JVM中</strong>。</li></ul></li> <li>并行垃圾回收器：和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。
<ul><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul></li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_1.png" alt="gc_collector_1"></p> <ol start="2"><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</li></ol> <ul><li>并发式垃圾回收器：指垃圾回收线程与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li> <li>独占式垃圾回收器：指垃圾回收线程一旦运行，就停止应用程序中的所有用户线程（Stop the world），直到垃圾回收过程完全结束。</li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_2.png" alt="gc_collector_2"></p> <ol start="3"><li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。
<ul><li>压缩式垃圾回收器：回收器在回收完成后，会对存活对象进行压缩整理，消除回收后的碎片。</li> <li>非压缩式垃圾回收器：回收器在回收完成后，不进行上述操作。</li></ul></li> <li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</li></ol> <h2 id="垃圾收集器性能指标"><a href="#垃圾收集器性能指标" class="header-anchor">#</a> 垃圾收集器性能指标</h2> <p>垃圾收集器性能评估指标主要有以下几点：</p> <ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li> <li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li> <li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li> <li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li> <li><strong>内存占用</strong>：Java堆区所占的内存大小。</li> <li>快速：一个对象从诞生到被回收所经历的时间。</li></ul> <p>其中<strong>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”</strong>。三者总体的表现会随着技术进步而越来越好，一款优秀的收集器通常最多同时满足其中的两项。其中，<strong>暂停时间的重要性日益凸显</strong>。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p> <p>简单来说，<strong>主要抓住两点：吞吐量、暂停时间</strong>。</p> <h3 id="吞吐量"><a href="#吞吐量" class="header-anchor">#</a> 吞吐量</h3> <p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</strong>。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p> <p>这种情况下，应用程序能容忍较高的暂停时间，因此，<strong>高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</strong>。</p> <p><strong>吞吐量优先，意味着在单位时间内，STW的时间最短</strong>：0.2 + 0.2 = 0.4</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_3.png" alt="gc_collector_3"></p> <h3 id="暂停时间"><a href="#暂停时间" class="header-anchor">#</a> 暂停时间</h3> <p>暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态。例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p> <p><strong>暂停时间优先，意味着尽可能让单次STW的时间最短</strong>：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_4.png" alt="gc_collector_4"></p> <h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="header-anchor">#</a> 吞吐量 vs 暂停时间</h3> <p>高吞吐量较好：这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。<strong>直觉上，吞吐量越高程序运行越快</strong>。</p> <p>低暂停时间（低延迟）较好：从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，<strong>具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序</strong>。</p> <p><strong>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）</strong>。</p> <ul><li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致<strong>GC需要更长的暂停时间</strong>来执行内存回收。</li> <li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又<strong>引起了年轻代内存的缩减和导致程序吞吐量的下降</strong>。</li></ul> <p>在设计或使用GC算法时，我们必须确定我们的目标：<strong>一个GC算法只可能针对两个目标之一</strong>（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p> <p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong>。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_vs.jpg" alt="gc_collector_vs"></p> <h2 id="不同垃圾回收器概述"><a href="#不同垃圾回收器概述" class="header-anchor">#</a> 不同垃圾回收器概述</h2> <p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p> <h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="header-anchor">#</a> 垃圾回收器发展史</h3> <p>有了虚拟机，就一定需要收集垃圾的机制(<code>Garbage Collection</code>)，对应的产品我们称为<code>Garbage Collector</code>。</p> <ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li> <li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li> <li>Parallel GC在JDK6之后成为HotSpot默认GC。</li> <li>2012年，在JDK1.7u4版本中，G1可用。</li> <li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li> <li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li> <li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li> <li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li> <li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li> <li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用</li></ul> <h3 id="_7种经典的垃圾收集器"><a href="#_7种经典的垃圾收集器" class="header-anchor">#</a> 7种经典的垃圾收集器</h3> <p>目前主要有7种经典的垃圾收集器，详细介绍可参考<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener noreferrer">GC官方手册<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ul><li>串行回收器：Serial、Serial Old</li> <li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li> <li>并发回收器：CMS、G1</li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_5.png" alt="gc_collector_5"></p> <h3 id="经典收集器与垃圾分代之间的关系"><a href="#经典收集器与垃圾分代之间的关系" class="header-anchor">#</a> 经典收集器与垃圾分代之间的关系</h3> <ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li> <li>老年代收集器：Serial Old、Parallel Old、CMS；</li> <li>整堆收集器：G1；</li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_classic_7.jpg" alt="gc_collector_classic_7"></p> <h3 id="经典收集器的组合关系"><a href="#经典收集器的组合关系" class="header-anchor">#</a> 经典收集器的组合关系</h3> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_group_7.jpg" alt="gc_collector_group_7"></p> <ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial+Serial Old、Serial+CMS、ParNew+Serial Old、ParNew+CMS、Parallel Scavenge+Serial Old、Parallel Scavenge+Parallel Old、G1；</li> <li>其中Serial Old作为CMS出现<code>Concurrent Mode Failure</code>失败的后备预案。</li> <li>红色虚线：由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214）。</li> <li>绿色虚线：JDK14中弃用Parallel Scavenge和Serial Old的GC组合（JEP366）</li> <li>绿色虚框：JDK14中删除CMS垃圾回收器（JEP363）</li></ol> <h3 id="不同的垃圾收集器概述"><a href="#不同的垃圾收集器概述" class="header-anchor">#</a> 不同的垃圾收集器概述</h3> <p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p> <p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。</p> <p>所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</p> <h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="header-anchor">#</a> 如何查看默认垃圾收集器</h3> <p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p> <p>或者使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p> <h2 id="serial回收器-串行回收"><a href="#serial回收器-串行回收" class="header-anchor">#</a> Serial回收器：串行回收</h2> <p>Serial收集器是<strong>最基本、历史最悠久</strong>的垃圾收集器了，JDK1.3之前它是回收新生代唯一的选择。</p> <p>Serial收集器作为HotSpot中<code>Client</code>模式下的默认新生代垃圾收集器。</p> <p><strong>Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收</strong>。</p> <p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<strong>Serial Old收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法</strong>。</p> <ul><li>Serial Old是运行在<code>Client</code>模式下默认的老年代的垃圾回收器</li> <li>Serial 0ld在<code>Server</code>模式下主要有两个用途
<ul><li>与新生代的Parallel Scavenge配合使用</li> <li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul> <h3 id="执行过程"><a href="#执行过程" class="header-anchor">#</a> 执行过程</h3> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_9.png" alt="gc_collector_9"></p> <p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程（Stop The World）</strong>，直到它收集结束</p> <p>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</p> <ul><li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li></ul> <p>缺点：他的优势也是它的缺点，在限定单核cpu才可以用。现在很多运行环境不是单核的了，这种垃圾收集器大家了解即可，而且对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <ul><li><code>-XX:+UseSerialGC</code>：指定年轻代和老年代都使用串行收集器。<strong>等价于新生代用Serial GC，且老年代用Serial Old GC</strong>。</li></ul> <h2 id="parnew回收器-并行回收"><a href="#parnew回收器-并行回收" class="header-anchor">#</a> ParNew回收器：并行回收</h2> <p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么<strong>ParNew收集器则是Serial收集器的多线程版本</strong>。</p> <ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul> <p>ParNew收集器除了<strong>采用并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是<strong>采用复制算法、&quot;Stop-the-World&quot;机制</strong>。</p> <p>ParNew是很多JVM运行在<code>Server</code>模式下新生代的默认垃圾收集器。<strong>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</strong>。</p> <ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li> <li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul> <h3 id="执行过程-2"><a href="#执行过程-2" class="header-anchor">#</a> 执行过程</h3> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_10.png" alt="gc_collector_10"></p> <p>注意，由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p> <ul><li>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li> <li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul> <h3 id="参数-2"><a href="#参数-2" class="header-anchor">#</a> 参数</h3> <ul><li><code>-XX:+UseParNewGC</code>：手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</li> <li><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和CPU数据相同的线程数。</li></ul> <h2 id="parallel回收器-吞吐量优先"><a href="#parallel回收器-吞吐量优先" class="header-anchor">#</a> Parallel回收器：吞吐量优先</h2> <p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>复制算法、并行回收和&quot;Stop the World&quot;机制</strong>。</p> <p>那么Parallel 收集器的出现是否多此一举？</p> <ul><li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量</strong>（Throughput），它也被称为<strong>吞吐量优先的垃圾收集器</strong>。</li> <li><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。</li></ul> <p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p> <h3 id="执行过程-3"><a href="#执行过程-3" class="header-anchor">#</a> 执行过程</h3> <p>Parallel Scavenge收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器，它采用了<strong>标记-压缩算法</strong>，但同样也是基于<strong>并行回收和&quot;Stop-the-World&quot;机制</strong>。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_11.png" alt="gc_collector_11"></p> <p><strong>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错</strong>。在Java8中默认是此垃圾收集器。</p> <h3 id="参数-3"><a href="#参数-3" class="header-anchor">#</a> 参数</h3> <ul><li><p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li> <li><p><code>-XX:+UseParallelOldGC</code> ：手动指定老年代都是使用并行回收收集器。</p> <ul><li>分别适用于新生代和老年代。在JDK8中是默认开启的。</li> <li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li> <li><p><code>-XX:ParallelGCThreads</code>: 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>G</mi><mi>C</mi><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>(</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mo>=</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mo>+</mo><mo stretchy="false">(</mo><mn>5</mn><mo>∗</mo><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">＿</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>(</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">ParallelGCThreads =  \begin{cases}  CPU\_Count &amp; \text (CPU\_Count &lt;= 8) \\  3 + (5 * CPU＿Count / 8) &amp; \text (CPU\_Count &gt; 8)  \end{cases}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">＿</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord">8</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">(</span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">(</span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li> <li><p><code>-XX:MaxGCPauseMillis</code>: 设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</p> <ul><li>为了尽可能地把停顿时间控制在<code>MaxGCPauseMills</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li> <li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合时使用Parallel，进行控制。</li> <li><strong>该参数使用需谨慎</strong>。</li></ul></li> <li><p><code>-XX:GCTimeRatio</code>: 垃圾收集时间占总时间的比例（=1/（N+1）），用于衡量吞吐量的大小。</p> <ul><li>取值范围（0, 100），默认值99，也就是垃圾回收时间不超过1%。</li> <li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li> <li><p><code>-XX:+UseAdaptivesizePolicy</code>: <strong>设置Parallel Scavenge收集器具有自适应调节策略</strong></p> <ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li> <li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</li></ul></li></ul> <h2 id="cms回收器-低延迟"><a href="#cms回收器-低延迟" class="header-anchor">#</a> CMS回收器：低延迟</h2> <p>在JDK1.5时期，HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p> <p>CMS收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p> <ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器就非常符合这类应用的需求。</li></ul> <p>CMS的垃圾收集算法<strong>采用标记-清除算法，并且也会&quot;Stop-the-World&quot;</strong>，由于采用这种算法，所以它的弊端之一就是内存碎片化。不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中<strong>使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个</strong>。</p> <p><strong>在G1出现之前，CMS使用还是非常广泛的，一直到今天，仍然有很多系统使用CMS GC</strong>。</p> <h3 id="执行过程-4"><a href="#执行过程-4" class="header-anchor">#</a> 执行过程</h3> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_12.png" alt="gc_collector_12"></p> <p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段：</p> <ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li> <li><strong>并发标记</strong>（Concurrent-Mark）阶段：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，用户线程可以与垃圾收集线程一起<strong>并发运行</strong>。</li> <li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象进行重新标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也<strong>远比并发标记阶段的时间短</strong>。</li> <li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以<strong>与用户线程同时并发</strong>的。</li></ul> <p>尽管CMS收集器采用的是并发回收（非独占式），但是<strong>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p> <p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</p> <p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，<strong>还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行</strong>。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，这时虚拟机将启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</strong>。</p> <p>CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将<strong>会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择<strong>空闲列表</strong>（Free List）执行内存分配。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_13.png" alt="gc_collector_13"></p> <p>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact？</p> <ul><li>答案其实很简单，因为<strong>当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢</strong>？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。<strong>Mark Compact更适合“Stop the World” 这种场景下使用</strong>。</li></ul> <h3 id="优缺点"><a href="#优缺点" class="header-anchor">#</a> 优缺点</h3> <p>优点：</p> <ul><li>并发收集</li> <li>低延迟</li></ul> <p>缺点：</p> <ul><li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足，<strong>在无法分配大对象的情况下，不得不提前触发FullGC</strong>。</li> <li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li> <li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现<code>Concurrent Mode Failure</code>失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul> <h3 id="参数-4"><a href="#参数-4" class="header-anchor">#</a> 参数</h3> <ul><li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器执行内存回收任务。
开启该参数后会自动将-xx:+UseParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。</li> <li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。
<ul><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%。</li> <li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li></ul></li> <li><code>-XX:+UseCMSCompactAtFullCollection</code>: 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li> <li><code>-XX:CMSFullGCsBeforeCompaction</code>: 设置在执行多少次Full GC后对内存空间进行压缩整理。</li> <li><code>-XX:ParallelcMSThreads</code>: 设置CMS的线程数量。
<ul><li>CMS默认启动的线程数是（ParallelGCThreads+3）/4，<code>ParallelGCThreads</code>是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul> <h3 id="jdk后续版本中cms的变化"><a href="#jdk后续版本中cms的变化" class="header-anchor">#</a> JDK后续版本中CMS的变化</h3> <ul><li><p>JDK9新特性：CMS被标记为<code>Deprecate</code>了（JEP291）</p> <p>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p></li> <li><p>JDK14新特性：删除CMS垃圾回收器（JEP363）</p> <p>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit，JVM会自动回退以默认GC方式启动JVM。</p></li></ul> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p> <p>请记住以下口令：</p> <ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li> <li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li> <li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ul> <h2 id="g1回收器-区域化分代式"><a href="#g1回收器-区域化分代式" class="header-anchor">#</a> G1回收器：区域化分代式</h2> <p>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</p> <ul><li>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而<strong>经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化</strong>。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li></ul> <p>也就是说为了适应现在不断扩大的内存和不断增加的处理器数量，垃圾回收器的发展方向是<strong>进一步降低暂停时间（Pause Time），同时兼顾良好的吞吐量</strong>。</p> <p>官方给<strong>G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p> <h3 id="g1简介与名称由来"><a href="#g1简介与名称由来" class="header-anchor">#</a> G1简介与名称由来</h3> <p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征</strong>。</p> <p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（<code>Region</code>）（物理上不连续的）。<strong>使用不同的<code>Region</code>来表示Eden、幸存者0区，幸存者1区，老年代等</strong>。</p> <p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个<code>Region</code>里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<em>优先列表</em>，<strong>每次根据允许的收集时间，优先回收价值最大的<code>Region</code></strong>。由于这种方式的<strong>侧重点在于回收垃圾最大量的区间（<code>Region</code>）</strong>，所以我们给G1一个名字：<strong>垃圾优先（Garbage First）</strong>。</p> <p>G1 GC在JDK1.7版本正式启用，移除了Experimenta1的标识，是<strong>JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合，被Oracle官方称为“全功能的垃圾收集器”。与此同时，CMS已经在JDK9中被标记为废弃（<code>deprecated</code>）。在JDK8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p> <h3 id="特点-优势"><a href="#特点-优势" class="header-anchor">#</a> 特点（优势）</h3> <p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p> <h4 id="并行与并发"><a href="#并行与并发" class="header-anchor">#</a> 并行与并发</h4> <ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程是STW的。</li> <li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul> <h4 id="分代收集"><a href="#分代收集" class="header-anchor">#</a> 分代收集</h4> <ul><li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li> <li><strong>将堆空间分为若干个区域（<code>Region</code>），这些区域中包含了逻辑上的年轻代和老年代</strong>。</li> <li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_14.png" alt="gc_collector_14"></p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_15.png" alt="gc_collector_15"></p> <h4 id="空间整合"><a href="#空间整合" class="header-anchor">#</a> 空间整合</h4> <p>G1针对CMS使用的“标记-清除”算法，导致的内存碎片、若干次GC后进行一次碎片整理的问题提出了新的解决方案。</p> <p>G1将内存划分为一个个的<code>Region</code>。内存的回收是以<code>Region</code>作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC，<strong>尤其是当Java堆非常大的时候，G1的优势更加明显</strong>。</p> <h4 id="可预测的停顿时间模型-即-软实时soft-real-time"><a href="#可预测的停顿时间模型-即-软实时soft-real-time" class="header-anchor">#</a> 可预测的停顿时间模型（即：软实时soft real-time）</h4> <p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，<strong>能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过M毫秒</strong>。</p> <ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li> <li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的<code>Region</code></strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</li> <li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集<strong>产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高</strong>。</p> <p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而<strong>G1在大内存应用上则发挥其优势</strong>，<strong>平衡点在6-8GB之间</strong>。</p> <h3 id="参数-5"><a href="#参数-5" class="header-anchor">#</a> 参数</h3> <ul><li><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务</li> <li><code>-XX:G1HeapRegionSize</code>：设置每个<code>Region</code>的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域，默认是堆内存的1/2000。</li> <li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是200ms（人的平均反应速度）</li> <li><code>-XX:+ParallelGCThread</code>：设置STW工作线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count &gt; 8时，ParallelGCThreads 也会大于8）</li> <li><code>-XX:ConcGCThreads</code>： 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</li> <li><code>-XX:InitiatingHeapOccupancyPercent</code>: 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC，默认值是45。</li></ul> <h3 id="常见操作步骤"><a href="#常见操作步骤" class="header-anchor">#</a> 常见操作步骤</h3> <p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p> <ul><li>第一步：开启G1垃圾收集器</li> <li>第二步：设置堆的最大内存</li> <li>第三步：设置最大的停顿时间</li></ul> <p>G1中提供了三种垃圾回收模式：<code>Young GC</code>、<code>Mixed GC</code>和<code>Full GC</code>，在不同的条件下被触发（后面会讲到）。</p> <h3 id="适用场景"><a href="#适用场景" class="header-anchor">#</a> 适用场景</h3> <ul><li><strong>面向服务端应用，针对具有大内存、多处理器的机器</strong>。（在普通大小的堆里表现并不惊喜）</li> <li>最主要的应用是需要<strong>低GC延迟</strong>，并具有大堆的应用程序提供解决方案。如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li> <li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：
<ul><li>超过50%的Java堆被活动数据占用；</li> <li>对象分配频率或年代提升频率变化很大；</li> <li>GC停顿时间过长（长于0.5至1秒）</li></ul></li></ul> <p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而<strong>G1 GC可以采用应用线程承担后台运行的GC工作</strong>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p> <h3 id="分区region-化整为零"><a href="#分区region-化整为零" class="header-anchor">#</a> 分区Region：化整为零</h3> <p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立<code>Region</code>块，每个<code>Region</code>块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的<code>Region</code>大小相同，且在JVM生命周期内不会被改变</strong>。虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分<code>Region</code>（不需要连续）的集合。<strong>通过<code>Region</code>的动态分配方式实现逻辑上的连续</strong>。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_16.png" alt="gc_collector_16"></p> <p>一个<code>Region</code>有可能属于Eden，Survivor或者Old/Tenured内存区域。但是<strong>一个Region只可能属于一个角色</strong>。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p> <p>G1垃圾收集器还增加了一种新的内存区域，叫做<code>Humongous</code>内存区域，如图中的H块。专门用于存储大对象，<strong>G1认为大小超过一个<code>Region</code>容量一半的对象即可判定为大对象</strong>，就放到<code>Humongous</code>内存区域。</p> <p>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，那么它就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个<code>Humongous</code>区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC，G1的大多数行为都把H区作为老年代的一部分来看待。</p> <p>分区的有点之一就是：<strong>每个<code>Region</code>都是通过指针碰撞来分配空间</strong>。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_17.png" alt="gc_collector_17"></p> <h3 id="g1的回收过程"><a href="#g1的回收过程" class="header-anchor">#</a> G1的回收过程</h3> <p>G1 GC的垃圾回收过程主要包括如下三个环节：</p> <ul><li>年轻代GC（Young GC）: 并行的独占式收集器</li> <li>老年代并发标记过程（Concurrent Marking）</li> <li>混合回收（Mixed GC）：如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</li></ul> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_18.png" alt="gc_collector_18"></p> <p>流程用顺时针来看：<strong>Young GC -&gt; Young GC + Concurrent Mark -&gt; Mixed GC顺序</strong>，进行垃圾回收。</p> <p>应用程序分配内存时候，<strong>当年轻代的Eden区用尽时开始年轻代回收</strong>过程；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</strong>。</p> <p>当堆内存使用<strong>达到一定值（默认45%）<strong>时，开始</strong>老年代并发标记</strong>过程。</p> <p><strong>标记完成马上开始混合回收过程</strong>。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代<code>Region</code>是和年轻代一起被回收的。</p> <p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p> <h3 id="remembered-set"><a href="#remembered-set" class="header-anchor">#</a> Remembered Set</h3> <p>针对一个对象被不同区域<code>Region</code>引用的问题，GC怎么处理？</p> <p>我们知道一个<code>Region</code>不可能是孤立的，一个<code>Region</code>中的对象可能被其他任意<code>Region</code>中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？其实在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ 如果这样的话显而会降低<code>MinorGC</code>的效率。</p> <p>具体解决方法：</p> <p>无论G1还是其他分代收集器，<strong>JVM都是使用<code>Remembered Set</code>来避免全局扫描</strong>。</p> <p>每个<code>Region</code>都有一个对应的<code>Remembered Set</code>；</p> <p>每次<code>Reference</code>类型数据写操作时，都会产生一个<code>Write Barrier</code>暂时中断操作；然后检查将要写入的引用指向的对象是否和该<code>Reference</code>类型数据在不同的<code>Region</code>。（其他收集器则是检查老年代对象是否引用了新生代对象）；</p> <p>如果不同，则通过<code>CardTable</code>把相关引用信息记录到引用指向对象的所在<code>Region</code>对应的<code>Remembered Set</code>中；</p> <p><strong>当进行垃圾收集时，在GC根节点的枚举范围加入<code>Remembered Set</code></strong>；就可以保证不进行全局扫描，也不会有遗漏。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_19.png" alt="gc_collector_19"></p> <h3 id="g1回收过程一-年轻代gc"><a href="#g1回收过程一-年轻代gc" class="header-anchor">#</a> G1回收过程一：年轻代GC</h3> <p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p> <p>年轻代垃圾回收<strong>只会回收Eden区和Survivor区</strong>。首先G1停止应用程序的执行（<strong>STW</strong>），G1创建<strong>回收集</strong>（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_20.png" alt="gc_collector_20"></p> <p>然后开始如下回收过程：</p> <ol><li><strong>第一阶段，扫描根</strong>。根是指<code>static</code>变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同<code>RSet</code>记录的外部引用作为扫描存活对象的入口。</li> <li><strong>第二阶段，更新<code>RSet</code></strong>。处理<code>dirty card queue</code>（见备注）中的<code>card</code>，更新<code>RSet</code>。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li> <li><strong>第三阶段，处理<code>RSet</code></strong>。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li> <li><strong>第四阶段，复制对象</strong>。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li> <li><strong>第五阶段，处理引用</strong>。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol> <div class="custom-block tip"><p class="custom-block-title">dirty card queue</p> <p>对于程序中的赋值语句的操作，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</p> <p>在年轻代回收时，G1会对队列中的所有card进行处理，更新RSet，保证RSet实时准确反映引用关系。（不在引用赋值语句直接处理更新RSet时为了性能的需要，因为更新RSet需要线程同步，开销大）</p> <p>每个Java线程有一个dirty card queue。这个队列有白、绿、黄、红四个颜色，表示应用线程往这个队列放任务的状态。</p> <p>White，表示没有应用线程往队列里放任务，什么事都不用干。Green，此时Refinement线程开始被激活，开始更新RSet。Yellow，此时全部的Refinement线程都被激活，来更新RSet。Red，这个时候，应用线程也开始参与排空队列的工作。</p> <p>相关参数：<code>-XX:G1ConcRefinementXXXZone</code>=N，其中XXX为相关的颜色，如Green、White。</p></div> <h3 id="g1回收过程二-并发标记过程"><a href="#g1回收过程二-并发标记过程" class="header-anchor">#</a> G1回收过程二：并发标记过程</h3> <ol><li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段是STW的，并且<strong>会触发一次年轻代GC</strong>。</li> <li><strong>根区域扫描（Root Region Scanning）</strong>：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。</li> <li><strong>并发标记（Concurrent Marking）</strong>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。<strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li> <li><strong>再次标记（Remark）</strong>：由于应用程序持续进行，需要修正上一次的标记结果，是STW的。G1中<strong>采用了比CMS更快的初始快照算法</strong>：snapshot-at-the-beginning（SATB）。</li> <li><strong>独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫，是STW的。<strong>这个阶段并不会实际上去做垃圾的收集</strong>。</li> <li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li></ol> <h3 id="g1回收过程三-混合回收"><a href="#g1回收过程三-混合回收" class="header-anchor">#</a> G1回收过程三：混合回收</h3> <p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了<strong>回收整个Young Region，还会回收一部分的Old Region</strong>。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以<strong>对垃圾回收的耗时时间进行控制</strong>。也要注意的是<strong>Mixed GC并不是Full GC</strong>。
<img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_21.png" alt="gc_collector_21"></p> <p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些<strong>老年代的内存分段会分8次</strong>（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p> <p><strong>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段</strong>。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p> <p>由于老年代中的内存分段默认分8次回收，<strong>G1会优先回收垃圾多的内存分段</strong>。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是<strong>垃圾占内存分段比例要达到65%才会被回收</strong>。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p> <p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是<strong>允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收</strong>。因为GC会花费很多的时间但是回收到的内存却很少（意思就是尽可能让混合回收有价值，这个价值判定就是垃圾很多值得回收，否则就不进行回收）。</p> <h3 id="g1回收可选的过程四-full-gc"><a href="#g1回收可选的过程四-full-gc" class="header-anchor">#</a> G1回收可选的过程四：Full GC</h3> <p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1仍会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，这个时候性能就会非常差，应用程序停顿时间会很长。（可以认为是个兜底过程，类似于CMS + Serial Old的配合）</p> <p>所以我们要尽量避免Full GC的发生，一旦发生我们需要进行调整：</p> <ul><li>一般来说可能是堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li> <li>回收阶段（Evacuation）的时候没有足够的to-space来存放晋升的对象；</li> <li>并发处理过程完成之前导致的空间耗尽。</li></ul> <div class="custom-block tip"><p class="custom-block-title">Evacuation</p> <p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分<code>Region</code>，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p></div> <h3 id="g1回收器优化建议"><a href="#g1回收器优化建议" class="header-anchor">#</a> G1回收器优化建议</h3> <p>年轻代大小的设置</p> <ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li> <li>避免固定年轻代的大小，因为会覆盖暂停时间目标</li></ul> <p>暂停时间目标不要太过严苛</p> <ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li> <li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <h3 id="_7种经典垃圾回收器总结"><a href="#_7种经典垃圾回收器总结" class="header-anchor">#</a> 7种经典垃圾回收器总结</h3> <p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p> <table><thead><tr><th>垃圾收集器</th> <th>分类</th> <th>作用位置</th> <th>使用算法</th> <th>特点</th> <th>适用场景</th></tr></thead> <tbody><tr><td><strong>Serial</strong></td> <td>串行运行</td> <td>作用于新生代</td> <td>复制算法</td> <td>响应速度优先</td> <td>适用于单CPU环境下的client模式</td></tr> <tr><td>ParNew</td> <td>并行运行</td> <td>作用于新生代</td> <td>复制算法</td> <td>响应速度优先</td> <td>多CPU环境Server模式下与CMS配合使用</td></tr> <tr><td><strong>Parallel</strong></td> <td>并行运行</td> <td>作用于新生代</td> <td>复制算法</td> <td>吞吐量优先</td> <td>适用于后台运算而不需要太多交互的场景</td></tr> <tr><td>Serial Old</td> <td>串行运行</td> <td>作用于老年代</td> <td>标记-压缩算法</td> <td>响应速度优先</td> <td>适用于单CPU环境下的Client模式</td></tr> <tr><td>Parallel Old</td> <td>并行运行</td> <td>作用于老年代</td> <td>标记-压缩算法</td> <td>吞吐量优先</td> <td>适用于后台运算而不需要太多交互的场景</td></tr> <tr><td><strong>CMS</strong></td> <td>并发运行</td> <td>作用于老年代</td> <td>标记-清除算法</td> <td>响应速度优先</td> <td>适用于互联网或B／S业务</td></tr> <tr><td><strong>G1</strong></td> <td>并发、并行运行</td> <td>作用于新生代、老年代</td> <td>标记-压缩算法、复制算法</td> <td>响应速度优先</td> <td>面向服务端应用</td></tr></tbody></table> <p>GC发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p> <h3 id="垃圾回收器组合"><a href="#垃圾回收器组合" class="header-anchor">#</a> 垃圾回收器组合</h3> <p>不同厂商、不同版本的虚拟机实现差距比较大，目前HotSpot虚拟机在 JDK7/8 后所有收集器及组合如下图：</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_22.png" alt="gc_collector_22"></p> <ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial+Serial Old、Serial+CMS、ParNew+Serial Old、ParNew+CMS、Parallel Scavenge+Serial Old、Parallel Scavenge+Parallel Old、G1；</li> <li>其中Serial Old作为CMS出现<code>Concurrent Mode Failure</code>失败的后备预案。</li> <li>红色虚线：由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214）。</li> <li>绿色虚线：JDK14中弃用Parallel Scavenge和Serial Old的GC组合（JEP366）</li> <li>绿色虚框：JDK14中删除CMS垃圾回收器（JEP363）</li></ol> <h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="header-anchor">#</a> 怎么选择垃圾回收器</h3> <p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p> <p>那么怎么选择垃圾收集器？</p> <ol><li>优先调整堆的大小让JVM自适应完成。</li> <li>如果内存小于100M，使用串行收集器</li> <li>如果是单核、单机程序，并且没有停顿时间的要求，选择串行收集器</li> <li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li> <li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器
官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ol> <p>最后需要明确一个观点：</p> <ol><li>没有最好的收集器，更没有万能的收集。</li> <li><strong>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</strong>。</li></ol> <div class="custom-block tip"><p class="custom-block-title">面试</p> <p>对于GC，面试官t通常会循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p> <ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li> <li>垃圾收集器工作的基本流程。</li></ul> <p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</p></div> <h2 id="新发展"><a href="#新发展" class="header-anchor">#</a> 新发展</h2> <p>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p> <p>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在Serverless等新的应用场景下，Serial GC找到了新的舞台</strong>。</p> <p>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK 9中已经被标记为废弃，并在JDK 14版本中移除。</p> <h3 id="jdk-11-新特性"><a href="#jdk-11-新特性" class="header-anchor">#</a> JDK 11 新特性</h3> <p><a href="http://openidk.iava.net/jeps/318" target="_blank" rel="noopener noreferrer">Epsilon<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：A No-Op GarbageCollector（Epsilon垃圾回收器，&quot;No-Op（无操作）&quot;回收器）</p> <p><a href="http://openidk.iava.net/jeps/333" target="_blank" rel="noopener noreferrer">ZGC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：A Scalable Low-Latency Garbage Collector（Experimental）（ZGC，可伸缩的低延迟垃圾回收器，处于实验性阶段）</p> <p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）。主打特点：低停顿时间</p> <h3 id="openjdk-12的shenandoash-gc"><a href="#openjdk-12的shenandoash-gc" class="header-anchor">#</a> OpenJDK 12的Shenandoash GC</h3> <p>OpenJDK 12的 Shenandoash GC：低停顿时间的GC（实验性）</p> <p>Shenandoah，无疑是众多GC中最孤独的一个。它是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器，不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p> <p>Shenandoah垃圾回收器最初由Red Hat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求，在2014年贡献给OpenJDK。</p> <p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_23.png" alt="gc_collector_23"></p> <p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p> <ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li> <li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul> <p>总结</p> <ul><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li> <li>Shenandoah GC的强项：低延迟时间。</li> <li>Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前<a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866" target="_blank" rel="noopener noreferrer">Java 12新特性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>视频里有过介绍。</li></ul> <h3 id="令人震惊、革命性的zgc"><a href="#令人震惊、革命性的zgc" class="header-anchor">#</a> 令人震惊、革命性的ZGC</h3> <p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/" target="_blank" rel="noopener noreferrer">ZGC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>与Shenandoah目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟</strong>。</p> <p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于<code>Region</code>内存布局的，（暂时）不设分代的，使用了<strong>读屏障、染色指针和内存多重映射等技术</strong>来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p> <p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong>等。</p> <p><strong>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_24.png" alt="gc_collector_24"></p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_25.png" alt="gc_collector_25"></p> <p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p> <p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器</strong>。</p> <p>JEP 364：ZGC应用在macOS上，JEP 365：ZGC应用在Windows上，直到JDK14之前，ZGC仅Linux才支持。</p> <p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macos上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macos上。现在mac或Windows上也能使用ZGC了，示例如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
</code></pre></div><p>推荐书籍：</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_26.png" alt="gc_collector_27"></p> <h3 id="其他垃圾回收器-aligc"><a href="#其他垃圾回收器-aligc" class="header-anchor">#</a> 其他垃圾回收器：AliGC</h3> <p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p> <p><img src="https://qiniu.wenwl.site/notes/jvm/gc_collector_27.png" alt="gc_collector_27"></p> <p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC：<a href="https://www.infoq.com/articles/azul_gc_in_detail" target="_blank" rel="noopener noreferrer">Zing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，有兴趣可以自行研究。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">3/8/2022, 9:09:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/java-vm/2_1_class_sys_introd.html">
        JVM基石：class文件
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc037eca.js" defer></script><script src="/assets/js/3.a3373ef9.js" defer></script><script src="/assets/js/166.be1e5538.js" defer></script>
  </body>
</html>
