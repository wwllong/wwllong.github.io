# Java泛型实例化

在开发中我们可能需要对传入的泛型实例化，按照以往的经验，我们很容易想到这种方式：`T t = new T()`，但是因为泛型的擦除，在编译期没法确定泛型参数化的类型，也就找不到对应的类字节码文件，所以无法实例化。简单来说就是T的具体类型我们无法获得，所以`new T()`是无法通过编译的。

## 工厂对象

为了得到泛型的实例化对象，我们可以使用`反射机制`，通过T的Class对象的newInstance()方法来获取它的实例：
``` java
public class ClassFactory<T> {
    T t;

    public void create(Class<T> clazz){
        try {
            t = clazz.newInstance();
        } catch (InstantiationException e | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    
}
```

但是`newInstance()`方法底层是调用了泛型类型的默认的构造函数，在传入像`Integer`没有默认的构造函数的类型，`ClassFactory<Integer>`在运行时就会抛出异常，而不会在编译时候捕获。通过显示工厂的方式，限制类型解决这个问题。

## 显式工厂
``` java
public class Factory<T> {

}
```


## 模板方法



参考：
1. https://blog.csdn.net/Sife_007/article/details/80308517
2. https://blog.csdn.net/zzq900503/article/details/36202353