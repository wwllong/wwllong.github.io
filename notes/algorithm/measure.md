# 算法基本概念

## 时间复杂度
时间复杂度评价算法流程的一个标准。具体来说他是一个算法流程中，常数操作数量的指标。

`常数时间的操作`：一个操作如果和数据量没有关系，每次都是
固定时间内完成的操作，叫做常数操作。
例如：数组寻址、加减乘除操作、位运算操作等等。

时间复杂度常用O（读作big O）来表示。具体来说，`在常数操作数量的表达式中，不要低阶项，只要高阶项，并且不要高阶项的系数，剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))。`
（数学极限)

说明评价一个算法的流程先看指标，也就是时间复杂度，在指标相同的情况下，再比较系数大小。

```
栗子：
一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。

算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；  
时间复杂度：O(M*N)

算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；  
时间复杂度：O(M * logN)

算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现的数； 
时间复杂度：O(M*logM ) + O(N+M)

显然方法1的时间复杂度是最差的，对于方法二、三需要确定具体的样本量才能分析优劣。对于数组A的长度较小的时候（N更小），方法二更好，因为logN更小；相反而言，对于数组B的长度较小的情况下，方法三更好。
```

## 递归行为的时间复杂度

master公式：`T(N) = a*T(N/b) + O(N^d)`  
```
N：父问题的样本量
N/b：子问题的样本量
a：划分为子问题的规模
1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)
```
master公式的使用，适用范围，父问题划分为子问题的规模是一样的。  
例如：求数组中最大数的递归方法。


## 对数器
- 有一个你想要测的方法a，
- 实现一个绝对正确但是复杂度不好的方法b，
- 实现一个随机样本产生器
- 实现比对的方法
- 把方法a和方法b比对很多次来验证方法a是否正确。
- 如果有一个样本使得比对出错，打印样本分析是哪个方法出错。
- 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。
  
