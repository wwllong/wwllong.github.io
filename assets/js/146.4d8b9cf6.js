(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{794:function(a,s,t){"use strict";t.r(s);var e=t(58),o=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("h2",{attrs:{id:"从虚拟机角度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从虚拟机角度"}},[a._v("#")]),a._v(" 从虚拟机角度")]),a._v(" "),t("p",[a._v("从java虚拟机的角度讲，只有两种不同的类加载器：")]),a._v(" "),t("ul",[t("li",[a._v("一种是"),t("code",[a._v("启动类加载器（Bootstrap ClassLoader）")]),a._v("，这个类加载器使用的是c++实现的，是虚拟机的一部分。")]),a._v(" "),t("li",[a._v("另一类是就是"),t("code",[a._v("所有其他类加载器")]),a._v("，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类。")])]),a._v(" "),t("h2",{attrs:{id:"从开发人员的角度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从开发人员的角度"}},[a._v("#")]),a._v(" 从开发人员的角度")]),a._v(" "),t("p",[a._v("从开发人员的角度看，类加载器还可以划分为3种系统类加载器:")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("启动类加载器（Bootstrap ClassLoader）")]),a._v("，负责加载存放在"),t("code",[a._v("<JAVA_HOME>/lib")]),a._v("目录中的，或者被"),t("code",[a._v("-Xbootclasspath")]),a._v("参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符的类库即使放在lib目录中也不会被加载）类库"),t("code",[a._v("加载到虚拟机中内存中")]),a._v("。"),t("code",[a._v("启动类加载器无法被java程序直接引用")]),a._v("，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用"),t("code",[a._v("null")]),a._v("代替即可。")]),a._v(" "),t("li",[t("code",[a._v("扩展类加载器（Extension ClassLoader）")]),a._v("：这个类加载器有sun.misc.Launcher$ExtClassLoader实现，负责加载"),t("code",[a._v("<JAVA_HOME>/lib/ext")]),a._v("目录中的，或者被"),t("code",[a._v("java.ext.dirs")]),a._v("系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。")]),a._v(" "),t("li",[t("code",[a._v("应用类加载器（Application ClassLoader）")]),a._v("：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以也称它为"),t("code",[a._v("系统类加载器（System ClassLoader）")]),a._v("。他负责"),t("code",[a._v("加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。")]),a._v("对此，如果有必要开发者可以加入自己定义的类加载器。")])]),a._v(" "),t("p",[a._v("一般对于我们java程序员来说，类的加载使用的是"),t("code",[a._v("双亲委派模型")]),a._v('，即当一个类需要加载时，会将类传给Application ClassLoader，但是Application ClassLoader并不会加载，不管它是否能加载，而是传给它的"父类" Extension ClassLoader，Extension ClassLoader同样不会加载，同样传给 Bootstrap ClassLoader（注意不是我们常说的那种父类，但是可以这样理解）,这时Bootstrap ClassLoader会判断它是否能加载，能加载就直接加载了，不能加载就传给Extension ClassLoader，Extension ClassLoader同样的判断是否能加载，能加载就直接加载，不能加载就传给Application ClassLoader，然后Application ClassLoader也判断能否加载，如果还是不能加载应该就是报ClassNotFoundException了。这就是双亲委托模型的简单理解了。')]),a._v(" "),t("p",[a._v('对于上面的"父类"为什么要打引号，因为它们并不是真的像java中继承的关系，而是组合的关系，即在"子类"中存在一个成员变量指向"父类"的引用。')]),a._v(" "),t("p",[t("code",[a._v("之所以使用双亲委托机制是为了保证java程序的稳定运作")]),a._v("，比如当你使用的不是双亲委托模型的时候，然后刚好开发者又定义了一个类，一个java.lang.String这样一个类，如果不使用双亲委托模型，当类加载的时候就有可能会加载开发者定义的String类，这导致了java代码的一片混乱，可读性极差。（PS：但这并不意味着类加载器只要双亲委托模型就行了，没有完美的模型，只有最合适的模型，有不同的需求使用不同的模型。比如破坏双亲委派模型，有兴趣的牛友可以自行了解），所以可以这么说，"),t("code",[a._v("不同的类加载器加载出来的类是不一样的，不同的类加载器加载同一个类会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同的Class实例。")]),a._v("对于接口，其实就是一个特殊的类，和类一样，在堆中产生不同的class对象。")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考：")]),a._v(" "),t("blockquote",[t("p",[a._v("https://www.nowcoder.com/test/question/done?tid=30929758&qid=373097#summary")])])])}),[],!1,null,null,null);s.default=o.exports}}]);