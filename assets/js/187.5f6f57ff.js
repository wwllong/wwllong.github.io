(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{835:function(a,t,s){"use strict";s.r(t);var e=s(58),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"jvm监控及诊断工具-gui篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm监控及诊断工具-gui篇"}},[a._v("#")]),a._v(" JVM监控及诊断工具-GUI篇")]),a._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),s("p",[a._v("使用命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("无法获取方法级别的分析数据")]),a._v("，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。")]),a._v(" "),s("li",[a._v("要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。")]),a._v(" "),s("li",[a._v("分析数据通过终端输出，结果展示不够直观。")])]),a._v(" "),s("p",[a._v("为此，JDK提供了一些内存泄漏的分析工具，如jconsole，jvisualvm等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。")]),a._v(" "),s("p",[s("strong",[a._v("JDK自带的工具")])]),a._v(" "),s("ul",[s("li",[a._v("jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等")]),a._v(" "),s("li",[s("strong",[a._v("Visual VM")]),a._v("：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。")]),a._v(" "),s("li",[a._v("JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。")])]),a._v(" "),s("p",[s("strong",[a._v("第三方工具")])]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("MAT")]),a._v("：MAT（Memory Analyzer Tool）是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗")]),a._v(" "),s("li",[s("strong",[a._v("JProfiler")]),a._v("：商业软件，需要付费。功能强大。")]),a._v(" "),s("li",[s("strong",[a._v("Arthas")]),a._v("：阿里巴巴开源的性能分析神器。")])]),a._v(" "),s("p",[a._v("推荐：Visual VM、MAT、Arthas、JProfiler。")]),a._v(" "),s("h2",{attrs:{id:"jconsole"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jconsole"}},[a._v("#")]),a._v(" JConsole")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("jconsole"),s("OutboundLink")],1),a._v("：从Java 5开始，在JDK中自带的Java监控和管理控制台。用于对JVM中内存、线程和类等的监控，是一个基于JMX（Java Management Extensions）的GUI性能监控工具。")]),a._v(" "),s("p",[s("strong",[a._v("启动")]),a._v("：在JDK_HOME/bin目录中找到"),s("code",[a._v("jconsole")]),a._v("可执行文件，双击或者使用命令行执行。")]),a._v(" "),s("p",[s("strong",[a._v("三种连接方式")])]),a._v(" "),s("ul",[s("li",[a._v("Local：使用JConsole连接一个正在本地系统运行的JVM，并且执行程序的和运行JConsole的需要是同一个用户。JConsole使用文件系统的授权通过RMI连接起链接到平台的MBean的服务器上。这种从本地连接的监控能力只有Sun的JDK具有。")]),a._v(" "),s("li",[a._v("Remote：使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi/rmi://hostName:portNum/jmxrmi。JConsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名和密码，从而进行授权。")]),a._v(" "),s("li",[a._v("Advanced：使用一个特殊的URL连接JMX代理。一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK 1.4的实现了JMX和JMX")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_jconsole_1.png",alt:"tuning_jconsole_1.png"}})]),a._v(" "),s("h2",{attrs:{id:"visual-vm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#visual-vm"}},[a._v("#")]),a._v(" Visual VM")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://visualvm.github.io/index.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Visual VM"),s("OutboundLink")],1),a._v("是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（"),s("code",[a._v("jps")]),a._v("，"),s("code",[a._v("jinfo")]),a._v("），监视应用程序的CPU、GC、堆、方法区及线程的信息（"),s("code",[a._v("jstat")]),a._v("、"),s("code",[a._v("jstack")]),a._v("）等，甚至代替"),s("code",[a._v("JConsole")]),a._v("。在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布(JDK_HOME/bin目录下)。")]),a._v(" "),s("p",[s("strong",[a._v("插件")]),a._v("：Visual VM的一大特点就是支持插件安装，可以通过"),s("a",{attrs:{href:"https://visualvm.github.io/pluginscenters.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("离线文件安装"),s("OutboundLink")],1),a._v("(*.nbm)，也可以在软件的插件页面在线下载安装。")]),a._v(" "),s("ul",[s("li",[a._v("推荐安装：VisualGC")]),a._v(" "),s("li",[a._v("此外，IDEA的插件市场中也有相关的Visual VM插件，用于开发的手调本地的Visual VM。")])]),a._v(" "),s("p",[s("strong",[a._v("两种连接方式")])]),a._v(" "),s("ul",[s("li",[a._v("本地连接：监控本地Java进程的CPU、类、线程等")]),a._v(" "),s("li",[a._v("远程连接：略，详细百度。")])]),a._v(" "),s("p",[s("strong",[a._v("主要功能")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("生成/读取堆内存快照")]),a._v(" "),s("li",[a._v("查看JVM参数和系统属性")]),a._v(" "),s("li",[a._v("查看运行中的虚拟机进程")]),a._v(" "),s("li",[a._v("生成/读取线程快照")]),a._v(" "),s("li",[a._v("程序资源的实时监控")]),a._v(" "),s("li",[a._v("JMX代理连接、远程环境监控、CPU分析和内存分析")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_visualvm_1.png",alt:"tuning_visualvm_1.png"}})]),a._v(" "),s("h2",{attrs:{id:"java-mission-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-mission-control"}},[a._v("#")]),a._v(" Java Mission Control")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/JDKMissionControl/jmc",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java Mission Control"),s("OutboundLink")],1),a._v("（简称JMC) ， Java官方提供的性能强劲的工具，是一个用于对 Java应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个GUI客户端以及众多用来收集Java虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。(Oracle整合JRockit VM的产物，JDK 7u40之后绑定发布)")]),a._v(" "),s("p",[a._v("JMC的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着JMC来做压测（唯一影响可能是 Full GC多了）。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_jmc_1.png",alt:"tuning_jmc_1.png"}})]),a._v(" "),s("p",[s("strong",[a._v("Java Flight Recorder")])]),a._v(" "),s("p",[a._v("Java Flight Recorder是JMC的其中一个组件，能够以极低的性能开销收集Java虚拟机的性能数据。与其他工具相比，JFR的性能开销很小，在默认配置下平均低于1%。JFR能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的Java程序。")]),a._v(" "),s("p",[a._v("Java Flight Recorder 和 JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。")]),a._v(" "),s("p",[a._v("当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：")]),a._v(" "),s("ul",[s("li",[a._v("瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。")]),a._v(" "),s("li",[a._v("持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。")]),a._v(" "),s("li",[a._v("计时事件(Timed Event) ，是时长超出指定阈值的持续事件。")]),a._v(" "),s("li",[a._v("取样事件（Sample Event)，是周期性取样的事件。")])]),a._v(" "),s("p",[a._v("取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_jmc_2.png",alt:"tuning_jmc_2.png"}})]),a._v(" "),s("h2",{attrs:{id:"eclipse-mat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eclipse-mat"}},[a._v("#")]),a._v(" Eclipse MAT")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.eclipse.org/mat/downloads.php",target:"_blank",rel:"noopener noreferrer"}},[a._v("MAT"),s("OutboundLink")],1),a._v("（Memory Analyzer Tool）工具是一款功能"),s("strong",[a._v("强大的Java堆内存分析器")]),a._v("。可以用于查找"),s("strong",[a._v("内存泄漏以及查看内存消耗")]),a._v("情况。MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。")]),a._v(" "),s("h3",{attrs:{id:"获取堆dump文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取堆dump文件"}},[a._v("#")]),a._v(" 获取堆dump文件")]),a._v(" "),s("p",[a._v("MAT可以专业分析Heap Dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：")]),a._v(" "),s("ul",[s("li",[a._v("所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。")]),a._v(" "),s("li",[a._v("所有的类信息，包括classloader、类名称、父类、静态变量等")]),a._v(" "),s("li",[a._v("GCRoot到所有的这些对象的引用路径")]),a._v(" "),s("li",[a._v("线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）")])]),a._v(" "),s("p",[s("strong",[a._v("说明")])]),a._v(" "),s("ul",[s("li",[a._v("MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM的 PHD 堆存储文件等都能被很好的解析。")]),a._v(" "),s("li",[a._v("最吸引人的还是能够"),s("strong",[a._v("快速为开发人员生成内存泄漏报表")]),a._v("，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。")])]),a._v(" "),s("p",[s("strong",[a._v("获取堆dump文件方式")])]),a._v(" "),s("ul",[s("li",[s("code",[a._v("jmap")]),a._v("命令")]),a._v(" "),s("li",[a._v("JVM参数配置（少用）："),s("code",[a._v("-XX:+HeapDumpOnOutOfMemoryError")]),a._v("或 "),s("code",[a._v("-XX:+HeapDumpBeforeFullGC")]),a._v("、 "),s("code",[a._v("-XX:HeapDumpPath=file_path")])]),a._v(" "),s("li",[a._v("VisualVM导出堆dump文件")])]),a._v(" "),s("h3",{attrs:{id:"分析堆dump文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析堆dump文件"}},[a._v("#")]),a._v(" 分析堆dump文件")]),a._v(" "),s("p",[a._v("MAT软件分析dump文件的几个功能入口：")]),a._v(" "),s("ul",[s("li",[a._v("histogram（柱状图）：展示了各个类的实例数目以及这些实例的Shallow heap（浅堆）或者Retained heap（深堆）的总和")]),a._v(" "),s("li",[a._v("thread overview（线程概览，小齿轮按钮）：查看系统中的Java线程、查看局部变量的信息")]),a._v(" "),s("li",[a._v("with outgoing references、with incoming references：获得对象互相引用的关系")]),a._v(" "),s("li",[a._v("Dominator Tree（支配树）：体现对象实例间的支配关系")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_mat_1.png",alt:"tuning_mat_1.png"}})]),a._v(" "),s("h2",{attrs:{id:"jprofiler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jprofiler"}},[a._v("#")]),a._v(" JProfiler")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.ej-technologies.com/products/jprofiler/overview.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JProfiler"),s("OutboundLink")],1),a._v(" 是由 "),s("code",[a._v("ej-technologies")]),a._v(" 公司开发的一款 Java 应用性能诊断工具，功能强大，但是收费。")]),a._v(" "),s("p",[s("strong",[a._v("特点")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("使用方便、界面操作友好（简单且强大）")]),a._v(" "),s("li",[a._v("对被分析的应用影响小（提供模板）")]),a._v(" "),s("li",[a._v("CPU，Thread，Memory分析功能尤其强大")]),a._v(" "),s("li",[a._v("支持对jdbc，noSql，jsp，servlet，socket等进行分析")]),a._v(" "),s("li",[a._v("支持多种模式（离线，在线）的分析")]),a._v(" "),s("li",[a._v("支持监控本地、远程的JVM")]),a._v(" "),s("li",[a._v("跨平台，拥有多种操作系统的安装版本")])]),a._v(" "),s("p",[s("strong",[a._v("主要功能")])]),a._v(" "),s("ul",[s("li",[a._v("方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法")]),a._v(" "),s("li",[a._v("内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用")]),a._v(" "),s("li",[a._v("线程和锁：JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题")]),a._v(" "),s("li",[a._v("高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析")])]),a._v(" "),s("p",[s("strong",[a._v("IDEA与JProfiler")])]),a._v(" "),s("ul",[s("li",[a._v("JProfiler中配置IDEA：Setting -> IDE Integrations")]),a._v(" "),s("li",[a._v("IDEA集成JProfiler：Plugins -> search : JProfiler")])]),a._v(" "),s("h3",{attrs:{id:"数据采集方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据采集方式"}},[a._v("#")]),a._v(" 数据采集方式")]),a._v(" "),s("p",[a._v("JProfier数据采集方式分为两种：Sampling（样本采集）和Instrumentation（重构模式）")]),a._v(" "),s("ul",[s("li",[a._v("Instrumentation：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。\n"),s("ul",[s("li",[a._v("优点：功能强大。在此设置中，调用堆栈信息是准确的。")]),a._v(" "),s("li",[a._v("缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析")])])]),a._v(" "),s("li",[a._v("Sampling（推荐）：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。\n"),s("ul",[s("li",[a._v("优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）")]),a._v(" "),s("li",[a._v("缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）")])])])]),a._v(" "),s("p",[a._v("注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_jprofiler_1.png",alt:"tuning_jprofiler_1.png"}})]),a._v(" "),s("h3",{attrs:{id:"菜单功能点概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#菜单功能点概述"}},[a._v("#")]),a._v(" 菜单功能点概述")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Telemetrie（遥感监测 ）：主要包括进程的内存、对象实例、吞吐量、GC活动、类、线程、CPU负载、自定义遥感监测等一些实时活动监测。")])]),a._v(" "),s("li",[s("p",[a._v("Live Memory（内存视图）：类以及实例对象的相关信息，例如对象的个数、大小，对象创建的方法执行栈、对象创建热点。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("● 所有对象 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("All")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Objects")]),a._v("：显示所有加载的类的列表和在堆上分配的实例数。只有"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Java")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.5")]),a._v("（JVMTI）才会显示此视图。\n● 记录对象 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Record")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Objects")]),a._v("：查看特定时间段对象的分配，并记录分配的调用堆栈。\n● 分配访问树 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Allocation")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Call")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Tree")]),a._v("：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。\n● 分配热点 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Allocation")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Hot")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Spots")]),a._v("：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。\n● 类追踪器 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Tracker")]),a._v("：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间\n")])])])]),a._v(" "),s("li",[s("p",[a._v("Heap Walker（堆遍历 ）：能生成dump文件、解析dump文件对堆内存快照进行分析。")])]),a._v(" "),s("li",[s("p",[a._v("Cpu Views（CPU视图）：JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("● 访问树 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Call")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Tree")]),a._v("：显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC，JMS和JNDI服务请求都被注释在请求树中。请求树可以根据"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Servlet")]),a._v("和JSP对URL的不同需要进行拆分。\n● 热点 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Hot")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Spots")]),a._v("：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算。\n● 访问图 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Call")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Graph")]),a._v("：显示一个从已选方法、类、包或J2EE组件开始的访问队列的图。\n● 方法统计 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Method")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Statistis")]),a._v("：显示一段时间内记录的方法的调用时间细节。\n")])])])]),a._v(" "),s("li",[s("p",[a._v("Threads（线程视图）：JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("● 线程历史 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("History")]),a._v("：显示一个与线程活动和线程状态在一起的活动时间表。\n● 线程监控 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Monitor")]),a._v("：显示一个列表，包括所有的活动线程以及它们目前的活动状况。\n● 线程转储 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Dumps")]),a._v("：显示所有线程的堆栈跟踪。\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),s("p",[a._v("线程分析主要关心三个方面：Web容器的线程最大数（比如：Tomcat的线程容量应该略大于最大并发数）；线程阻塞；线程死锁")])])]),a._v(" "),s("li",[s("p",[a._v("Monitors&locks（监视器&锁 ）：所有线程持有锁的情况以及锁的信息。观察JVM的内部线程并查看状态。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("● 死锁探测图表 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Current")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Locking")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Graph")]),a._v("：显示JVM中的当前死锁图表。\n● 目前使用的监测器 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Current")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Monitors")]),a._v("：显示目前使用的监测器并且包括它们的关联线程。\n● 锁定历史图表 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Locking")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("History")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Graph")]),a._v("：显示记录在JVM中的锁定历史。\n● 历史检测记录 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Monitor")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("History")]),a._v("：显示重大的等待事件和阻塞事件的历史记录。\n● 监控器使用统计 "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Monitor")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Usage")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Statistics")]),a._v("：显示分组监测，线程和监测类的统计监测数据\n")])])])])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_jprofiler_2.png",alt:"tuning_jprofiler_2.png"}})]),a._v(" "),s("h2",{attrs:{id:"arthas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arthas"}},[a._v("#")]),a._v(" Arthas")]),a._v(" "),s("p",[a._v("上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。")]),a._v(" "),s("p",[a._v("那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？")]),a._v(" "),s("p",[a._v("阿里巴巴开源的性能分析神器Arthas应运而生。")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://arthas.aliyun.com/zh-cn/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Arthas"),s("OutboundLink")],1),a._v("（阿尔萨斯）是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。Arthas 支持JDK 6＋，支持Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。")]),a._v(" "),s("h3",{attrs:{id:"官方文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#官方文档"}},[a._v("#")]),a._v(" 官方文档")]),a._v(" "),s("p",[a._v("Arthas的文档很齐全，这里列举可能会用到的文档入口，更多内容见"),s("a",{attrs:{href:"https://arthas.aliyun.com/doc/",target:"_blank",rel:"noopener noreferrer"}},[a._v("官方文档"),s("OutboundLink")],1),a._v("：")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://arthas.aliyun.com/doc/install-detail.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("快速安装"),s("OutboundLink")],1),a._v(" 、"),s("a",{attrs:{href:"https://arthas.aliyun.com/doc/docker.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Docker Arthas"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://arthas.aliyun.com/doc/quick-start.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("快速入门"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://arthas.aliyun.com/doc/web-console.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Web Console"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://arthas.aliyun.com/doc/advanced-use.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("进阶使用"),s("OutboundLink")],1)])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_arthas_1.png",alt:"tuning_arthas_1.png"}})]),a._v(" "),s("p",[a._v("Web Console：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_arthas_2.png",alt:"tuning_arthas_2.png"}})]),a._v(" "),s("h2",{attrs:{id:"其他工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他工具"}},[a._v("#")]),a._v(" 其他工具")]),a._v(" "),s("p",[s("strong",[a._v("Flame Graphs（火焰图）")]),a._v("：在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。网上的关于Java火焰图的讲解大部分来自于"),s("a",{attrs:{href:"http://new.brendangregg.com/flamegraphs.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Brenden Gregg的博客"),s("OutboundLink")],1),a._v("。（火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。）")]),a._v(" "),s("p",[s("a",{attrs:{href:"http://github.com/alibaba/Tprofiler",target:"_blank",rel:"noopener noreferrer"}},[s("strong",[a._v("Tprofiler")]),s("OutboundLink")],1),a._v("：案例，使用JDK自身提供的工具进行JVM调优可以将下 TPS 由2.5提升到20（提升了7倍），并准确定位系统瓶颈。")]),a._v(" "),s("p",[a._v("系统瓶颈有：应用里静态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。")]),a._v(" "),s("p",[a._v("那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了GC过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了4倍，即提升到100。")]),a._v(" "),s("ul",[s("li",[a._v("Tprofiler配置部署、远程操作、 日志阅读都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶预。")]),a._v(" "),s("li",[a._v("Tprofiler最重要的特性就是能够统计出你指定时间段内 JVM 的 top method，这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。")])]),a._v(" "),s("p",[s("strong",[a._v("Btrace")]),a._v("：常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发，个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常用的。BTrace则是SUN Kenai 云计算开发平台下的一个开源项目，旨在为Java提供安全可靠的动态跟踪分析工具。")]),a._v(" "),s("p",[a._v("其他的工具还有YourKit、JProbe、Spring Insight等等。")])])}),[],!1,null,null,null);t.default=r.exports}}]);