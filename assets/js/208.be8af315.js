(window.webpackJsonp=window.webpackJsonp||[]).push([[208],{856:function(a,t,e){"use strict";e.r(t);var s=e(58),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"对象访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象访问"}},[a._v("#")]),a._v(" 对象访问")]),a._v(" "),e("p",[a._v("Java语言中，对象访问是如何进行的?\n最简单的访问，也会涉及到Java栈、Java堆、方法区三者之间的关联。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//出现在方法体中")]),a._v("\n")])])]),e("p",[a._v("“Object obj”这部分语义将反应到Java栈的本地变量表中，作为一个"),e("code",[a._v("refrence类型数据")]),a._v("出现。而“new Obeject”这部分语义反应到Java堆中，形成了存储Object类型实例所有数据值的结构化内存（根据具体的类型以及虚拟机实例不同，长度不固定）。此外，Java堆中还必须包含能查找到此对象类型数据（对象类型、父类、实现的接口、方法等等）的地址信息，这些类型数据存储在方法区中。")]),a._v(" "),e("p",[a._v("在JVM规范中只规定了"),e("code",[a._v("refrence类型")]),a._v("为一个指向对象的引用，而没有定义引用如何定位以及访问到Java堆中对象的方式（即栈定位并访问堆中对象信息的方式）。目前主流方式有两种："),e("code",[a._v("使用句柄和直接指针。")])]),a._v(" "),e("h2",{attrs:{id:"句柄引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#句柄引用"}},[a._v("#")]),a._v(" 句柄引用")]),a._v(" "),e("p",[a._v("如果使用句柄访问，"),e("code",[a._v("Java堆中会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了两个地址信息，分别是对象实例数据和类型数据地址信息。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"imgs/access_obj_handle.png",alt:"句柄访问对象"}})]),a._v(" "),e("h2",{attrs:{id:"直接引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接引用"}},[a._v("#")]),a._v(" 直接引用")]),a._v(" "),e("p",[a._v("如果使用直接指针访问方式，Java堆对象的布局就要考虑"),e("code",[a._v("如何放置访问类型数据的相关信息")]),a._v("，"),e("code",[a._v("reference直接存储的就是对象地址。")])]),a._v(" "),e("p",[e("img",{attrs:{src:"imgs/access_obj_direct.png",alt:"直接引用"}})]),a._v(" "),e("h2",{attrs:{id:"区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别")]),a._v(" "),e("p",[a._v("句柄引用和直接引用两种对象访问方式各有优势。")]),a._v(" "),e("p",[a._v("使用句柄引用的方式最大的优点是：reference中存储的是稳定的句柄地址，在对象被移动（GC时，移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要被修改。")]),a._v(" "),e("p",[a._v("使用直接指针访问方式最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此此类开销积少成多后也是一项非常可观的执行成本。")]),a._v(" "),e("p",[a._v("HotSpot采用直接引用的方式进行对象的访问。")])])}),[],!1,null,null,null);t.default=r.exports}}]);