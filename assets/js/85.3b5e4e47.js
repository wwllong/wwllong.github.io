(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{691:function(e,t,v){"use strict";v.r(t);var _=v(58),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"哈希表和有序表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哈希表和有序表"}},[e._v("#")]),e._v(" 哈希表和有序表")]),e._v(" "),v("h2",{attrs:{id:"哈希表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哈希表"}},[e._v("#")]),e._v(" 哈希表")]),e._v(" "),v("ol",[v("li",[e._v("哈希表在使用层面上可以理解为一种集合结构")]),e._v(" "),v("li",[e._v("如果只有key，没有伴随数据value，可以使用HashSet结构")]),e._v(" "),v("li",[e._v("如果既有key，又有伴随数据value，可以使用HashMap结构")]),e._v(" "),v("li",[e._v("有无伴随数据value，是HashMap和HashSet唯一的区别，实际结构是一样的")]),e._v(" "),v("li",[e._v("使用哈希表curd操作（put、remove、put、get），可以认为时间复杂度为"),v("strong",[e._v("O(1)")]),e._v("，但是常数时间比较大")]),e._v(" "),v("li",[e._v("放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个基础类型的大小（包括String）")]),e._v(" "),v("li",[e._v("放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节")])]),e._v(" "),v("h2",{attrs:{id:"有序表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序表"}},[e._v("#")]),e._v(" 有序表")]),e._v(" "),v("ol",[v("li",[e._v("有序表在使用层面上也可以理解为一种集合结构")]),e._v(" "),v("li",[e._v("如果只有key，没有伴随数据value，可以使用TreeSet结构")]),e._v(" "),v("li",[e._v("如果既有key，又有伴随数据value，可以使用TreeMap结构")]),e._v(" "),v("li",[e._v("有无伴随数据value，是TreeSet和TreeSet唯一的区别，实际结构是一样的")]),e._v(" "),v("li",[e._v("与哈希表的区别是，乱序操作之后它是有序的，它有一些额外的api，如firstKey、lastKey、floorKey、ceilingKey等等")]),e._v(" "),v("li",[e._v("使用有序表curd（put、remove、put、get）等操作，可以认为时间复杂度为"),v("strong",[e._v("O(logN)")])]),e._v(" "),v("li",[e._v("放入有序表的东西，如果是基础类型，内部按值传递，内存占用是这个基础类型的大小（包括String）")]),e._v(" "),v("li",[e._v("放入有序表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节，排序通过"),v("strong",[e._v("比较器")])]),e._v(" "),v("li",[e._v("有序表的实现有多种：AVL、SB、红黑树、跳表")])])])}),[],!1,null,null,null);t.default=a.exports}}]);