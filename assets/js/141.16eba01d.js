(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{787:function(a,t,s){"use strict";s.r(t);var v=s(58),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"变量和类型转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量和类型转换"}},[a._v("#")]),a._v(" 变量和类型转换")]),a._v(" "),s("h2",{attrs:{id:"变量的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量的概念"}},[a._v("#")]),a._v(" 变量的概念")]),a._v(" "),s("p",[a._v("变量是内存中的一个存储区域，该区域有自己的名称（变量名）和类型（数据类型），该区域的数据可以在同一类型范围内不断变化。也就是说定义的变量可以用来不断的存放统一类型的常量，并可以重复使用。可以理解将变量理解成数学中的未知数。")]),a._v(" "),s("p",[a._v("定义变量的格式："),s("strong",[a._v("数据类型 变量名 = 初始化值;")])]),a._v(" "),s("h2",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),s("p",[a._v("在定义变量的时候，需要声明变量是属于那种数据类型。而Java是强语言类型，对于每一种数据都定义了明确且具体的数据类型，在内存中分配了不同的内存空间。Java数据类型分为两大类：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("基本数据类型")]),a._v(" "),s("ul",[s("li",[a._v("数值型\n"),s("ul",[s("li",[a._v("整数类型（byte，short，"),s("strong",[a._v("int")]),a._v("，long）")]),a._v(" "),s("li",[a._v("浮点类型（float，"),s("strong",[a._v("double")]),a._v("）")])])]),a._v(" "),s("li",[a._v("字符型（char）")]),a._v(" "),s("li",[a._v("布尔型（boolean）")])])]),a._v(" "),s("li",[s("p",[a._v("引用数据类型")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("类（class）")])]),a._v(" "),s("li",[s("p",[a._v("接口（interface）")])]),a._v(" "),s("li",[s("p",[a._v("数组（[]）")])])])])]),a._v(" "),s("p",[s("strong",[a._v("其中整数类型默认为int，浮点类型默认为double。"),s("strong",[a._v("因为这个机制，在定义和使用变量的时候会出现")]),a._v("自动类型提升")]),a._v("的现象。")]),a._v(" "),s("p",[a._v("基本数据类型使用的字节以及取值范围：")]),a._v(" "),s("p",[a._v("byte：1字节，-128 ~ 127")]),a._v(" "),s("p",[a._v("shor： 2字节，-2^15 ~ 2^15-1")]),a._v(" "),s("p",[a._v("int：4字节，-2^31~2 ^31-1 （上亿）")]),a._v(" "),s("p",[a._v("long: 8字节，略")]),a._v(" "),s("p",[a._v("float：4字节，略")]),a._v(" "),s("p",[a._v("double：8字节，略")]),a._v(" "),s("p",[a._v("char："),s("strong",[a._v("2字节")])]),a._v(" "),s("p",[a._v("Boolean：true或者false")]),a._v(" "),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[a._v("#")]),a._v(" 注意事项")]),a._v(" "),s("ul",[s("li",[a._v("确定使用变量的作用域（一对{}之间有效），避免超出范围")]),a._v(" "),s("li",[a._v("初始化值，避免自动类型提升（尽管某些智能开发工具，会提示初始化值无意义，但是还是尽量养成初始化值的习惯）")])]),a._v(" "),s("h2",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("当数据不确定的时候。需要对数据进行存储时，就定义一个变量来完成存储动作。")]),a._v(" "),s("h2",{attrs:{id:"类型提升-强制转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型提升-强制转换"}},[a._v("#")]),a._v(" 类型提升&强制转换")]),a._v(" "),s("p",[a._v("类型转换是指将某种数据类型转换为另一种数据类型。类型转换分为两种：")]),a._v(" "),s("ul",[s("li",[a._v("自动类型转换（隐式类型转换）")]),a._v(" "),s("li",[a._v("强制类型转换（显式类型转换）")])]),a._v(" "),s("p",[a._v("类型转换的原理：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("类型转换操作在寄存器中完成。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("转换以占用内存大的类型为主")]),a._v("。小数据往大数据转换，数据保持完整，大数据往小数据转换，数据精度会损失。")])]),a._v(" "),s("li",[s("p",[a._v("负数会将以前的空位进行零填充。")])])]),a._v(" "),s("p",[a._v("表达式中数据类型自动提升：")]),a._v(" "),s("ul",[s("li",[a._v("所有的byte类型、short类型和char的值将被提升到int类型。")]),a._v(" "),s("li",[a._v("如果一个操作数是long类型，计算结果就是long类型。")]),a._v(" "),s("li",[a._v("如果一个操作数是float类型，计算结果就是float类型。")]),a._v(" "),s("li",[a._v("如果一个操作数是double类型，计算结果就是double类型。")])]),a._v(" "),s("p",[a._v("自动类型提升的例子：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("x是占用4个字节的整型变量，而y是占用1个字节的字节型变量，在进行相加运算的时候，计算机会将y变量进行自动类型转换，将y提升为占用4个字节的整型变量，最后x+y进行相加的结果也是个整型，这样就可以赋值给x变量。")]),a._v(" "),s("p",[a._v("自动类型提升失败的例子：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("上述代码在编译时期就会报错，因为3在Java中默认为int类型，而y被自动提升为整型，3 + y 语句计算结果为整型，整性是不可以赋值给byte类型的。当然你也可以进行强制类型转换：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("如上，强制类型转换只需要使用括号将要强制转换类型括起来即可。但是"),s("strong",[a._v("强制类型转换是比较危险的，容易丢失数据，因为强转就是将一些位强行砍掉")]),a._v("。示例中的计算结果是正确的，那是因为砍掉之后的位刚好等于正确的结果：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("00000000 00000000 00000000 0000 0111\n强转后：\n0111 = 7\n")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);