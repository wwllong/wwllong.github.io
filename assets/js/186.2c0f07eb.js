(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{834:function(t,a,v){"use strict";v.r(a);var _=v(58),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"jvm监控及诊断工具-命令行篇"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm监控及诊断工具-命令行篇"}},[t._v("#")]),t._v(" JVM监控及诊断工具-命令行篇")]),t._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("p",[t._v("性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。我们知道可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。")]),t._v(" "),v("p",[t._v("JVM"),v("strong",[t._v("监控&调优体会")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("使用数据说明问题，使用知识分析问题，使用工具处理问题。")])]),t._v(" "),v("li",[v("strong",[t._v("无监控、不调优！")])])]),t._v(" "),v("p",[v("strong",[t._v("简单命令行工具")])]),t._v(" "),v("p",[t._v("在我们刚接触Java学习的时候，大家肯定最先了解的两个命令就是"),v("code",[t._v("javac")]),t._v("，"),v("code",[t._v("java")]),t._v("，那么除此之外，还有没有其他的命令可以供我们使用呢？")]),t._v(" "),v("p",[t._v("我们进入到安装JDK的"),v("code",[t._v("bin")]),t._v("目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。附，"),v("a",{attrs:{href:"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools",target:"_blank",rel:"noopener noreferrer"}},[t._v("辅助工具源码地址"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("mac系统下JDK 8示例：/Library/Java/JavaVirtualMachines/jdk1.8.0_271.jdk/Contents/Home/bin")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_cmd_1.png",alt:"tuning_cmd_1"}})]),t._v(" "),v("p",[t._v("其实JVM的监控工具主要分为命令行和GUI软件（图形用户界面），这里只要讲命令行工具。不要建议死记硬背，在有需要的时候翻阅，多实践。"),v("strong",[t._v("在忘记命令参数的时候可以使用帮助信息，即"),v("code",[t._v("xxx -h")]),t._v("或"),v("code",[t._v("xxx -help")])]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"jps-查看正在运行的java进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jps-查看正在运行的java进程"}},[t._v("#")]),t._v(" jps：查看正在运行的Java进程")]),t._v(" "),v("p",[v("code",[t._v("jps")]),t._v("(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。")]),t._v(" "),v("h3",{attrs:{id:"基本语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("p",[v("code",[t._v("jps")]),t._v("基本使用语法为："),v("code",[t._v("jps [options] [hostid]")]),t._v("。 在不加任何参数的情况下，输出结果为本地虚拟机唯一ID + 主类的名称。可以通过追加参数，来打印额外的信息。更多说明参见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("options：详见下文。")]),t._v(" "),v("li",[t._v("hostid：详见下文。")])]),t._v(" "),v("h3",{attrs:{id:"options参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#options参数"}},[t._v("#")]),t._v(" options参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-q")]),t._v(" "),v("td",[t._v("仅仅显示LVMID（Local Virtual Machine ID），即本地虚拟机唯一ID，不显示主类的名称等")])]),t._v(" "),v("tr",[v("td",[t._v("-l")]),t._v(" "),v("td",[t._v("输出应用程序主类的全类名或jar完整路径（如果进程执行的是jar包）。")])]),t._v(" "),v("tr",[v("td",[t._v("-m")]),t._v(" "),v("td",[t._v("输出虚拟机进程启动时传递给主类main()的参数")])]),t._v(" "),v("tr",[v("td",[t._v("-v")]),t._v(" "),v("td",[t._v("列出虚拟机进程启动时的JVM参数。比如："),v("code",[t._v("-Xms20m -Xmx50m")]),t._v("是启动程序指定的JVM参数。")])])])]),t._v(" "),v("p",[t._v("以上参数可以综合使用。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v("如果某 Java 进程关闭了默认开启的"),v("code",[t._v("UsePerfData")]),t._v("参数（即使用参数"),v("code",[t._v("-XX:-UsePerfData")]),t._v("），那么"),v("code",[t._v("jps")]),t._v("命令（以及下面介绍的"),v("code",[t._v("jstat")]),t._v("）将无法探知该Java 进程。")])]),t._v(" "),v("h3",{attrs:{id:"hostid参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hostid参数"}},[t._v("#")]),t._v(" hostid参数")]),t._v(" "),v("p",[v("code",[t._v("RMI")]),t._v("注册表中注册的主机名。如果想要远程监控主机上的 Java 程序，需要安装"),v("code",[t._v("jstatd")]),t._v("。")]),t._v(" "),v("p",[t._v("对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到"),v("code",[t._v("IP")]),t._v("地址欺诈攻击。如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行"),v("code",[t._v("jstatd")]),t._v("服务器，而是在本地使用"),v("code",[t._v("jstat")]),t._v("和"),v("code",[t._v("jps")]),t._v("工具。")]),t._v(" "),v("h2",{attrs:{id:"jstat-查看jvm统计信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jstat-查看jvm统计信息"}},[t._v("#")]),t._v(" jstat：查看JVM统计信息")]),t._v(" "),v("p",[v("code",[t._v("jstat")]),t._v("（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。更多说明参见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("p",[t._v("它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。")]),t._v(" "),v("h3",{attrs:{id:"基本语法-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-2"}},[t._v("#")]),t._v(" "),v("strong",[t._v("基本语法")])]),t._v(" "),v("p",[v("code",[t._v("jstat")]),t._v("基本使用语法为："),v("code",[t._v("jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("option：详见下文")]),t._v(" "),v("li",[t._v("vmid：指JVM进程ID，也就是"),v("code",[t._v("jps")]),t._v("看到前面的号码(本地虚拟机唯一ID)，必填。")]),t._v(" "),v("li",[t._v("interval：用于指定输出统计数据的周期，单位为毫秒。即：查询间隔")]),t._v(" "),v("li",[t._v("count：用于指定查询的总次数")]),t._v(" "),v("li",[t._v("-t：可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒")]),t._v(" "),v("li",[t._v("-h： 可以在周期性数据输出时，输出多少行数据后输出一个表头信息")])]),t._v(" "),v("h3",{attrs:{id:"option参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#option参数"}},[t._v("#")]),t._v(" option参数")]),t._v(" "),v("p",[v("code",[t._v("jstat")]),t._v("的option参数大体可以分为三类：类装载相关的、垃圾回收相关的以及JIT相关的。")]),t._v(" "),v("p",[t._v("类装载相关的：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-class")]),t._v(" "),v("td",[t._v("显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等")])])])]),t._v(" "),v("p",[t._v("垃圾回收相关的（后面附上表头说明）：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-gc")]),t._v(" "),v("td",[t._v("显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。")])]),t._v(" "),v("tr",[v("td",[t._v("-gccapacity")]),t._v(" "),v("td",[t._v("显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。")])]),t._v(" "),v("tr",[v("td",[t._v("-gcutil")]),t._v(" "),v("td",[t._v("显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。")])]),t._v(" "),v("tr",[v("td",[t._v("-gccause")]),t._v(" "),v("td",[t._v("与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。")])]),t._v(" "),v("tr",[v("td",[t._v("-gcnew")]),t._v(" "),v("td",[t._v("显示新生代GC状况")])]),t._v(" "),v("tr",[v("td",[t._v("-gcnewcapacity")]),t._v(" "),v("td",[t._v("显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间")])]),t._v(" "),v("tr",[v("td",[t._v("-geold")]),t._v(" "),v("td",[t._v("显示老年代GC状况")])]),t._v(" "),v("tr",[v("td",[t._v("-gcoldcapacity")]),t._v(" "),v("td",[t._v("显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间")])]),t._v(" "),v("tr",[v("td",[t._v("-gcpermcapacity")]),t._v(" "),v("td",[t._v("显示永久代使用到的最大、最小空间。")])])])]),t._v(" "),v("p",[t._v("附，"),v("code",[t._v("jstat")]),t._v("输出结果主要表头相关说明：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("表头")]),t._v(" "),v("th",[t._v("含义（存储单位字节，时间则为秒）")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("S0C")]),t._v(" "),v("td",[t._v("幸存者0区的大小")])]),t._v(" "),v("tr",[v("td",[t._v("S1C")]),t._v(" "),v("td",[t._v("幸存者1区的大小")])]),t._v(" "),v("tr",[v("td",[t._v("S0U")]),t._v(" "),v("td",[t._v("幸存者0区已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("S1U")]),t._v(" "),v("td",[t._v("幸存者1区已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("EC")]),t._v(" "),v("td",[t._v("Eden区的大小")])]),t._v(" "),v("tr",[v("td",[t._v("EU")]),t._v(" "),v("td",[t._v("Eden区已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("OC")]),t._v(" "),v("td",[t._v("老年代的大小")])]),t._v(" "),v("tr",[v("td",[t._v("OU")]),t._v(" "),v("td",[t._v("老年代已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("MC")]),t._v(" "),v("td",[t._v("元空间的大小")])]),t._v(" "),v("tr",[v("td",[t._v("MU")]),t._v(" "),v("td",[t._v("元空间已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("CCSC")]),t._v(" "),v("td",[t._v("压缩类空间的大小")])]),t._v(" "),v("tr",[v("td",[t._v("CCSU")]),t._v(" "),v("td",[t._v("压缩类空间已使用的大小")])]),t._v(" "),v("tr",[v("td",[t._v("YGC")]),t._v(" "),v("td",[t._v("从应用程序启动到采样时Young GC的次数")])]),t._v(" "),v("tr",[v("td",[t._v("YGCT")]),t._v(" "),v("td",[t._v("从应用程序启动到采样时Young GC消耗时间（秒）")])]),t._v(" "),v("tr",[v("td",[t._v("FGC")]),t._v(" "),v("td",[t._v("从应用程序启动到采样时Full GC的次数")])]),t._v(" "),v("tr",[v("td",[t._v("FGCT")]),t._v(" "),v("td",[t._v("从应用程序启动到采样时的Full GC的消耗时间（秒）")])]),t._v(" "),v("tr",[v("td",[t._v("GCT")]),t._v(" "),v("td",[t._v("从应用程序启动到采样时GC的总时间")])])])]),t._v(" "),v("p",[t._v("JIT相关的：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-compiler")]),t._v(" "),v("td",[t._v("显示JIT编译器编译过的方法、耗时等信息")])]),t._v(" "),v("tr",[v("td",[t._v("-printcompilation")]),t._v(" "),v("td",[t._v("输出已经被JIT编译的方法")])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("jstat 可以用来判断是否出现内存泄漏。")]),t._v(" "),v("p",[t._v("第1步：在长时间运行的 Java 程序中，我们可以运行"),v("code",[t._v("jstat")]),t._v("命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。")]),t._v(" "),v("p",[t._v("第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。")])]),t._v(" "),v("h2",{attrs:{id:"jinfo-实时查看和修改jvm配置参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jinfo-实时查看和修改jvm配置参数"}},[t._v("#")]),t._v(" jinfo：实时查看和修改JVM配置参数")]),t._v(" "),v("p",[v("code",[t._v("jinfo")]),t._v("(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。更多说明参见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("p",[t._v("在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了"),v("code",[t._v("jinfo")]),t._v("工具，开发人员可以很方便地找到Java虚拟机参数的当前值。")]),t._v(" "),v("h3",{attrs:{id:"基本语法-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-3"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("p",[v("code",[t._v("jinfo")]),t._v("基本使用语法为："),v("code",[t._v("jinfo [option] <pid>")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("option：详见下文。")]),t._v(" "),v("li",[t._v("pid：指JVM进程ID，必填。")])]),t._v(" "),v("h3",{attrs:{id:"option参数-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#option参数-2"}},[t._v("#")]),t._v(" option参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("no option")]),t._v(" "),v("td",[t._v("输出全部的参数和系统属性")])]),t._v(" "),v("tr",[v("td",[t._v("-flag name")]),t._v(" "),v("td",[t._v("输出对应名称的参数")])]),t._v(" "),v("tr",[v("td",[t._v("-flag [+-]name")]),t._v(" "),v("td",[t._v("开启或者关闭对应名称的参数，只有被标记为"),v("code",[t._v("manageable")]),t._v("的参数才可以被动态修改。")])]),t._v(" "),v("tr",[v("td",[t._v("-flag name=value")]),t._v(" "),v("td",[t._v("设定对应名称的参数")])]),t._v(" "),v("tr",[v("td",[t._v("-flags")]),t._v(" "),v("td",[t._v("输出全部的参数")])]),t._v(" "),v("tr",[v("td",[t._v("-sysprops")]),t._v(" "),v("td",[t._v("输出系统属性")])])])]),t._v(" "),v("p",[t._v("注意，"),v("code",[t._v("jinfo")]),t._v("不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。但是，并非所有参数都支持动态修改！只有被标记为"),v("code",[t._v("manageable")]),t._v("的参数才可以被动态修改，也就是说这个修改是有限的。如下，是标记为"),v("code",[t._v("manageable")]),t._v("的参数（不同JDK版本，参数可能不同）：")]),t._v(" "),v("div",{staticClass:"language-shell extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[t._v("wenwl@wenwls-iMac ~ % java -XX:+PrintFlagsFinal -version "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("grep")]),t._v(" manageable\n     intx CMSAbortablePrecleanWaitMillis            "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("                                 "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     intx CMSTriggerInterval                        "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" -1                                  "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     intx CMSWaitDuration                           "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v("                                "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool HeapDumpAfterFullGC                       "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool HeapDumpBeforeFullGC                      "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool HeapDumpOnOutOfMemoryError                "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    ccstr HeapDumpPath                              "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("                                     "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    uintx MaxHeapFreeRatio                          "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("                                 "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    uintx MinHeapFreeRatio                          "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("                                   "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintClassHistogram                       "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintClassHistogramAfterFullGC            "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintClassHistogramBeforeFullGC           "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintConcurrentLocks                      "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintGC                                   "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintGCDateStamps                         "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintGCDetails                            "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintGCID                                 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     bool PrintGCTimeStamps                         "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("                               "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("manageable"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\njava version "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1.8.0_271"')]),t._v("\nJava"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TM"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" SE Runtime Environment "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("build "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.8")]),t._v(".0_271-b09"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nJava HotSpot"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TM"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("64")]),t._v("-Bit Server VM "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("build "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("25.271")]),t._v("-b09, mixed mode"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("拓展")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("java -XX:+PrintFlagsInitial")]),t._v("：查看所有JVM参数启动的初始值。")]),t._v(" "),v("li",[v("code",[t._v("java -XX:+PrintFlagsFinal")]),t._v("：查看所有JVM参数的最终值(值前面添加冒号: 的是修改之后的值，没有添加的都是没有发生改变的初始值)。")]),t._v(" "),v("li",[v("code",[t._v("java -参数名称:+PrintCommandLineFlags")]),t._v("：查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值")])])]),t._v(" "),v("h2",{attrs:{id:"jmap-导出内存印象文件-内存使用情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jmap-导出内存印象文件-内存使用情况"}},[t._v("#")]),t._v(" jmap：导出内存印象文件&内存使用情况")]),t._v(" "),v("p",[v("code",[t._v("jmap")]),t._v("（JVM Memory Map）：作用一方面是获取"),v("code",[t._v("dump")]),t._v("文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。更详细的说明参见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"基本语法-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-4"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("p",[v("code",[t._v("jmap")]),t._v("的基本语法如下：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("jmap [option] <pid>")]),t._v("：option详细见下文，")]),t._v(" "),v("li",[v("code",[t._v("jmap [option] <executable <core>")]),t._v("："),v("code",[t._v("<executable <core>")]),t._v("代表可执行的代码，比如使用 "),v("code",[t._v("> 文件名称")]),t._v(" 来指定生成的dump文件的生成位置。")]),t._v(" "),v("li",[v("code",[t._v("jmap [option] [server_id@] <remote server IP or hostname>")]),t._v("："),v("code",[t._v("[server_id@]<……>")]),t._v("是为远程连接准备的。")])]),t._v(" "),v("h3",{attrs:{id:"option参数-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#option参数-3"}},[t._v("#")]),t._v(" option参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[t._v("-dump")])]),t._v(" "),v("td",[t._v("生成dump文件（Java堆转储快照）。特别的，"),v("code",[t._v("-dump:live")]),t._v("只保存堆中的存活对象")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("-heap")])]),t._v(" "),v("td",[t._v("输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("-histo")])]),t._v(" "),v("td",[t._v("输出堆空间中对象的统计信息，包括类、实例数量和合计容量。特别的，"),v("code",[t._v("-histo:live")]),t._v("只统计堆中的存活对象")])]),t._v(" "),v("tr",[v("td",[t._v("-finalizerinfo")]),t._v(" "),v("td",[t._v("显示在F-Queue中等待Finalizer线程执行finalize方法的对象，仅linux/solaris平台有效")])]),t._v(" "),v("tr",[v("td",[t._v("-permstat")]),t._v(" "),v("td",[t._v("以ClassLoader为统计口径输出永久代的内存状态信息，仅linux/solaris平台有效")])]),t._v(" "),v("tr",[v("td",[t._v("-F")]),t._v(" "),v("td",[t._v("当虚拟机进程对-dump选项没有任何响应时，强制执行生成dump文件，仅linux/solaris平台有效")])]),t._v(" "),v("tr",[v("td",[t._v("-J <flag>")]),t._v(" "),v("td",[t._v("传递参数给jmap启动的jvm")])])])]),t._v(" "),v("p",[t._v("这些参数和linux下输入显示的命令多少会有不同，包括也受JDK版本的影响。")]),t._v(" "),v("h3",{attrs:{id:"使用1-导出内存映像文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用1-导出内存映像文件"}},[t._v("#")]),t._v(" 使用1：导出内存映像文件")]),t._v(" "),v("p",[t._v("一般来说，使用"),v("code",[t._v("jmap")]),t._v("指令生成dump文件的操作算是最常用的jmap命令之一，即将堆中所有存活对象导出一个文件之中。")]),t._v(" "),v("p",[t._v("Heap Dump又叫堆存储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在出发内存快照的时候会保存此刻的信息，具体如下：")]),t._v(" "),v("ul",[v("li",[t._v("All Objects：Class, fields, primitive values and references")]),t._v(" "),v("li",[t._v("All Classes：ClassLoader, name,super class, static fields")]),t._v(" "),v("li",[t._v("Garbage Collection Roots：Objects defined to be reachable by the JVM")]),t._v(" "),v("li",[t._v("Thread Stacks and Local Variables：The call-stacks of threads at the moment of the snapshot, and per-frame information about   local objects.")])]),t._v(" "),v("p",[t._v("导出内存映像文件，分为手动方式以及自动方式，在介绍之前注意一下事项：")]),t._v(" "),v("ol",[v("li",[t._v("通常在写Heap Dump文件前会触发一次Full GC，所以Heap Dump文件保存的都是Full GC留下的对象信息。（自动方式才会这样做，而手动不会在Full GC之后生成Dump）。")]),t._v(" "),v("li",[t._v("由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长时间完成。。")])]),t._v(" "),v("h4",{attrs:{id:"手动方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#手动方式"}},[t._v("#")]),t._v(" 手动方式")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("jmap -dump:format=b,file=<filename.hprof> <pid>")])]),t._v(" "),v("li",[v("code",[t._v("jmap -dump:live,format=b,file=<filename.hprof> <pid>")])])]),t._v(" "),v("p",[t._v("说明：")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("<filename.hprof>")]),t._v(" 中的"),v("code",[t._v("filename")]),t._v("是导出文件名称，而"),v("code",[t._v(".hprof")]),t._v("是后缀名，该值可以省略。")]),t._v(" "),v("li",[v("code",[t._v("<pid>")]),t._v("是进程ID。")]),t._v(" "),v("li",[v("code",[t._v("format=b")]),t._v("表示生成的是标准的dump文件，用来进行格式限定")]),t._v(" "),v("li",[v("code",[t._v("-dump:live")]),t._v("指只dump出存活的对象。")])]),t._v(" "),v("h4",{attrs:{id:"自动方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动方式"}},[t._v("#")]),t._v(" 自动方式")]),t._v(" "),v("p",[t._v("当程序发生OOM退出系统，一些瞬时信息都随着程序终止而消失，而重现OOM问题往往比较困难或耗时，若此时能够在OOM时刻，自动导出dump文件就显得非常迫切。这里介绍一种比较常用的取得堆快照文档的方法：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("-XX:+HeapDumpOnOutOfMemoryError")]),t._v("：在程序OOM时，导出应用程序堆快照。")]),t._v(" "),v("li",[v("code",[t._v("-XX:HeapDumpPath=<filename.hprof>")]),t._v("：指定堆快照保存位置")])]),t._v(" "),v("h3",{attrs:{id:"使用2-显示堆内存相关信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用2-显示堆内存相关信息"}},[t._v("#")]),t._v(" 使用2：显示堆内存相关信息")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("jmap -heap <pid>")]),t._v(": 只是时间点上的堆信息，而"),v("code",[t._v("jstat")]),t._v("后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具 ，例如"),v("code",[t._v("JVisualVM")]),t._v("等，它们可以用图表的方式动态展示出相关信息，更加直观明了。")]),t._v(" "),v("li",[v("code",[t._v("jmap -histo <pid>")]),t._v(": 输出堆中对象的同级信息，包括类、实例数量和合计容量，也是这一时刻的内存中的对象信息。")])]),t._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("注意，由于"),v("code",[t._v("jmap")]),t._v("将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，"),v("code",[t._v("jmap")]),t._v("需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由"),v("code",[t._v("jmap")]),t._v("导出的堆快照必定是安全点位置的，这可能导致基于该堆快照的分析结果存在偏差。")]),t._v(" "),v("p",[t._v("举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么"),v("code",[t._v(":live")]),t._v("选项将无法探知到这些对象。另外，如果某个线程长时间无法跑到安全点，"),v("code",[t._v("jmap")]),t._v("将一直等下去。与前面讲的"),v("code",[t._v("jstat")]),t._v("则不同，垃圾回收器会主动将"),v("code",[t._v("jstat")]),t._v("所需要的摘要数据保存至固定位置之中，而"),v("code",[t._v("jstat")]),t._v("只需直接读取即可。")]),t._v(" "),v("h2",{attrs:{id:"jhat-jdk自导堆分析工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jhat-jdk自导堆分析工具"}},[t._v("#")]),t._v(" jhat：JDK自导堆分析工具")]),t._v(" "),v("p",[v("code",[t._v("jhat")]),t._v("(JVM Heap Analysis Tool)：Sun JDK提供的"),v("code",[t._v("jhat")]),t._v("命令与"),v("code",[t._v("jmap")]),t._v("命令搭配使用，用于分析"),v("code",[t._v("jmap")]),t._v("生成的"),v("code",[t._v("heap dump")]),t._v("文件（堆转储快照）。"),v("code",[t._v("jhat")]),t._v("内置了一个微型的HTTP/HTML服务器，生成"),v("code",[t._v("dump")]),t._v("文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。更多详见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("使用了"),v("code",[t._v("jhat")]),t._v("命令，就启动了一个"),v("code",[t._v("http")]),t._v("服务，端口是"),v("code",[t._v("7000")]),t._v("，即"),v("code",[t._v("http://localhost:7000/")]),t._v("，就可以在浏览器里分析。")]),t._v(" "),v("p",[v("strong",[t._v("说明："),v("code",[t._v("jhat")]),t._v("命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替，所以该指令只需简单了解一下即可")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"基本语法-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-5"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("p",[v("code",[t._v("jhat")]),t._v("基本语法："),v("code",[t._v("jhat <option> <dumpfile>")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("option：见下文")]),t._v(" "),v("li",[t._v("dumpfile：要解析的dump文件")])]),t._v(" "),v("h3",{attrs:{id:"option参数-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#option参数-4"}},[t._v("#")]),t._v(" option参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-stack false｜true")]),t._v(" "),v("td",[t._v("关闭｜打开对象分配调用栈跟踪")])]),t._v(" "),v("tr",[v("td",[t._v("-refs false｜true")]),t._v(" "),v("td",[t._v("关闭｜打开对象引用跟踪")])]),t._v(" "),v("tr",[v("td",[t._v("-port port-number")]),t._v(" "),v("td",[t._v("设置"),v("code",[t._v("jhat")]),t._v(" HTTP Server的端口号，默认7000")])]),t._v(" "),v("tr",[v("td",[t._v("-exclude exclude-file")]),t._v(" "),v("td",[t._v("执行对象查询时需要排除的数据成员")])]),t._v(" "),v("tr",[v("td",[t._v("-baseline exclude-file")]),t._v(" "),v("td",[t._v("指定一个基准堆转储")])]),t._v(" "),v("tr",[v("td",[t._v("-debug int")]),t._v(" "),v("td",[t._v("设置debug级别")])]),t._v(" "),v("tr",[v("td",[t._v("-version")]),t._v(" "),v("td",[t._v("启动后显示版本信息就退出")])]),t._v(" "),v("tr",[v("td",[t._v("-J <flag>")]),t._v(" "),v("td",[t._v("传入启动参数，比如"),v("code",[t._v("-J-Xmx512m")])])])])]),t._v(" "),v("h2",{attrs:{id:"jstack-打印jvm线程快照"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jstack-打印jvm线程快照"}},[t._v("#")]),t._v(" jstack：打印JVM线程快照")]),t._v(" "),v("p",[v("code",[t._v("jstack")]),t._v("（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。更多详见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方帮助文档"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("p",[t._v("生成线程快照的作用：可用于"),v("strong",[t._v("定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题")]),t._v("。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用"),v("code",[t._v("jstack")]),t._v("显示各个线程调用的堆栈情况。")]),t._v(" "),v("p",[t._v("在Thread Dump中，要留意下面几种状态：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("死锁，Deadlock（重点关注）")])]),t._v(" "),v("li",[v("strong",[t._v("等待资源，Waiting on condition（重点关注）")])]),t._v(" "),v("li",[v("strong",[t._v("等待获取监视器，Waiting on monitor entry（重点关注）")])]),t._v(" "),v("li",[v("strong",[t._v("阻塞，Blocked（重点关注）")])]),t._v(" "),v("li",[t._v("执行中，Runnable")]),t._v(" "),v("li",[t._v("暂停，Suspended")]),t._v(" "),v("li",[t._v("对象等待中，Object.wait() 或 TIMED＿WAITING")]),t._v(" "),v("li",[t._v("停止，Parked")])]),t._v(" "),v("h3",{attrs:{id:"基本语法-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-6"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("jstack [-l] <pid>：")]),t._v("连接到正在运行的进程")]),t._v(" "),v("li",[v("code",[t._v("jstack -F [-m] [-l] <pid>")]),t._v("：连接到挂起的进程")]),t._v(" "),v("li",[v("code",[t._v("jstack [-m] [-l] <executable> <core>")]),t._v("：连接到核心文件")]),t._v(" "),v("li",[v("code",[t._v("jstack [-m] [-l] [server_id@]<remote server IP or hostname>")]),t._v("：连接到远程调试服务器，远程服务器需要配置RMI。")])]),t._v(" "),v("h3",{attrs:{id:"option参数-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#option参数-5"}},[t._v("#")]),t._v(" option参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("参数选项")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-F")]),t._v(" "),v("td",[t._v("当正常输出的请求不被响应时，强制输出线程堆栈")])]),t._v(" "),v("tr",[v("td",[t._v("-l")]),t._v(" "),v("td",[t._v("除堆栈外，显示关于锁的附加信息")])]),t._v(" "),v("tr",[v("td",[t._v("-m")]),t._v(" "),v("td",[t._v("如果调用本地方法的话，可以显示C/C++的堆栈")])])])]),t._v(" "),v("h2",{attrs:{id:"jcmd-多功能命令行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jcmd-多功能命令行"}},[t._v("#")]),t._v(" jcmd：多功能命令行")]),t._v(" "),v("p",[t._v("在JDK 1.7以后，新增了一个命令行工具"),v("code",[t._v("jcmd")]),t._v("。它是一个多功能的工具，可以用来实现前面除了"),v("code",[t._v("jstat")]),t._v("之外所有命令的功能。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。更多详见"),v("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jcmd.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方帮助文档"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("p",[v("code",[t._v("jcmd")]),t._v("拥有"),v("code",[t._v("jmap")]),t._v("的大部分功能，并且在Oracle的官方网站上也推荐使用"),v("code",[t._v("jcmd")]),t._v("命令代"),v("code",[t._v("jmap")]),t._v("命令。")]),t._v(" "),v("h3",{attrs:{id:"基本语法-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法-7"}},[t._v("#")]),t._v(" 基本语法")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("jcmd -l")]),t._v(": 列出所有的JVM进程。")]),t._v(" "),v("li",[v("code",[t._v("jcmd <pid> hlep")]),t._v(":  针对指定的进程，列出支持的所有具体命令")]),t._v(" "),v("li",[v("code",[t._v("jcmd <pid | main class> <command ...|PerfCounter.print|-f file>")]),t._v(": 针对指定的进程，使用某个具体命令")])]),t._v(" "),v("p",[t._v("例如某个进程支持的所有具体命令：")]),t._v(" "),v("div",{staticClass:"language-shell extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[t._v("wenwl@wenwls-iMac ~ % jcmd "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("64886")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("help")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("64886")]),t._v(":\nThe following commands are available:\nJFR.stop\nJFR.start\nJFR.dump\nJFR.check\nVM.native_memory\nVM.check_commercial_features\nVM.unlock_commercial_features\nManagementAgent.stop\nManagementAgent.start_local\nManagementAgent.start\nVM.classloader_stats\nGC.rotate_log\nThread.print\nGC.class_stats\nGC.class_histogram\nGC.heap_dump\nGC.finalizer_info\nGC.heap_info\nGC.run_finalization\nGC.run\nVM.uptime\nVM.dynlibs\nVM.flags\nVM.system_properties\nVM.command_line\nVM.version\n"),v("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("help")]),t._v("\n\nFor "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("more")]),t._v(" information about a specific "),v("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("command")]),t._v(" use "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'help <command>'")]),v("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v("\n")])])]),v("p",[t._v("这些指令通常是可以替换上文提到的指令操作：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Thread.print")]),t._v(" 可以替换 "),v("code",[t._v("jstack")]),t._v(" 指令")]),t._v(" "),v("li",[v("code",[t._v("GC.class_histogram")]),t._v(" 可以替换"),v("code",[t._v("jmap")]),t._v("中的"),v("code",[t._v("-histo")]),t._v("操作")]),t._v(" "),v("li",[v("code",[t._v("GC.heap_dump")]),t._v(" 可以替换"),v("code",[t._v("jmap")]),t._v("中的"),v("code",[t._v("-dump")]),t._v("操作")]),t._v(" "),v("li",[v("code",[t._v("GC.run")]),t._v(" 可以查看GC的执行情况")]),t._v(" "),v("li",[v("code",[t._v("VM.uptime")]),t._v(" 可以查看程序的总执行时间，可以替换"),v("code",[t._v("jstat")]),t._v("指令中的"),v("code",[t._v("-t")]),t._v("操作")]),t._v(" "),v("li",[v("code",[t._v("VM.system_properties")]),t._v(" 可以替换 "),v("code",[t._v("jinfo -sysprops <pid>")])]),t._v(" "),v("li",[v("code",[t._v("VM.flags")]),t._v(" 可以获取JVM的配置参数信息")])]),t._v(" "),v("h2",{attrs:{id:"jstatd-远程主机信息收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jstatd-远程主机信息收集"}},[t._v("#")]),t._v(" jstatd：远程主机信息收集")]),t._v(" "),v("p",[t._v("之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如"),v("code",[t._v("jps")]),t._v("、"),v("code",[t._v("jstat")]),t._v("）。为了启用远程监控，则需要配合使用"),v("code",[t._v("jstatd")]),t._v(" 工具。命令"),v("code",[t._v("jstatd")]),t._v("是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。"),v("code",[t._v("jstatd")]),t._v("服务器将本机的Java应用程序信息传递到远程计算机。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/jstatd%E7%9A%84%E7%90%86%E8%A7%A3.png",alt:"jstatd"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);