(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{853:function(t,_,a){"use strict";a.r(_);var v=a(58),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"jvm笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm笔记"}},[t._v("#")]),t._v(" JVM笔记")]),t._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("这里归档了关于Java虚拟机的学习笔记或文章，笔记主要来源为：")]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1PJ411n7xZ",target:"_blank",rel:"noopener noreferrer"}},[t._v("尚硅谷宋红康JVM全套教程（详解java虚拟机）"),a("OutboundLink")],1)]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.yuque.com/u21195183/jvm",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM从入门到精通"),a("OutboundLink")],1),t._v("，这个是另一个博主对上面教程做的笔记，更加接近原版教程")]),t._v(" "),a("li",[t._v("官方公众号资料：下载链接：https://pan.baidu.com/s/1-EqdKhISTwEqto_14FrlQw ，提取码：mx3i")])])]),t._v(" "),a("li",[a("p",[t._v("周志明的《深入理解Java虚拟机-JVM高级特效与最佳实践（第3版）》。")])])]),t._v(" "),a("p",[t._v("笔记根据个人的学习过程、思考，会有所修改、调整。")]),t._v(" "),a("h2",{attrs:{id:"走近java"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#走近java"}},[t._v("#")]),t._v(" 走近Java")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_1_foreword.html"}},[t._v("JVM前言")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_2_java_jvm_introd.html"}},[t._v("Java与JVM简介")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_3_jvm_framework.html"}},[t._v("JVM的架构模型")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_4_jvm_life_cycle.html"}},[t._v("JVM生命周期")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_5_java_histroy.html"}},[t._v("Java的发展重大事件")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/0_6_jvm_family.html"}},[t._v("JVM家族")])],1),t._v(" "),a("li",[t._v("实战自己编译JDK")])]),t._v(" "),a("h2",{attrs:{id:"内存与垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存与垃圾回收"}},[t._v("#")]),t._v(" 内存与垃圾回收")]),t._v(" "),a("blockquote",[a("p",[t._v("Java与C++之间有一堵动态分配和垃圾收集技术所围成的高墙，墙外的人想进去，墙里面的人想出来。")])]),t._v(" "),a("p",[t._v("Java的自动内存管理机制学习JVM的重要一节。JVM是java程序的内存管理的“皇帝”，了解虚拟机如何管理内存，方便java程序员检查内存泄漏和内存溢出方面的问题。这一部分核心内容为内存区的划分与垃圾收集器技术，也是面试常考的知识点。")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_1_memory_structure.html"}},[t._v("JVM内存结构图")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_2_class_loading_sys.html"}},[t._v("类加载器子系统")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_3_runtime_data_area_ov.html"}},[t._v("运行时数据区")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_4_pc_register.html"}},[t._v("程序计数器（PC寄存器）")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_5_vm_statck.html"}},[t._v("虚拟机栈")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_6_native_method_stack.html"}},[t._v("本地方法栈")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_7_heap.html"}},[t._v("堆")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_8_methods_area.html"}},[t._v("方法区")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_9_new_object.html"}},[t._v("对象的实例化")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_10_direct_memory.html"}},[t._v("直接内存")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_11_execution_engine.html"}},[t._v("执行引擎")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_12_string_table.html"}},[t._v("String Table")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_13_gc_introd.html"}},[t._v("垃圾回收概述")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_14_gc_concept.html"}},[t._v("垃圾回收相关概念")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_15_gc_algs.html"}},[t._v("垃圾回收算法")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_16_gc_collector.html"}},[t._v("垃圾收集器")])],1)]),t._v(" "),a("h2",{attrs:{id:"字节码与类加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字节码与类加载"}},[t._v("#")]),t._v(" 字节码与类加载")]),t._v(" "),a("blockquote",[a("p",[t._v("代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步。")])]),t._v(" "),a("p",[t._v("各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_1_class_sys_introd.html"}},[t._v("JVM基石：class文件")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_2_class_file_struct.html"}},[t._v("class文件结构")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_2_1_class_file_javap.html"}},[t._v("javap解析class文件")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_3_bytecode_instruction_set.html"}},[t._v("字节码指令集")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_4_class_loading_process.html"}},[t._v("类的加载过程")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/2_5_class_loader.html"}},[t._v("再谈类的加载过程")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/appendix_classfile_struct.html"}},[t._v("附：字节码文件结构手册")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/appendix_bytecode.html"}},[t._v("附：字节码指令手册")])],1)]),t._v(" "),a("h2",{attrs:{id:"性能监控与调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能监控与调优"}},[t._v("#")]),t._v(" 性能监控与调优")]),t._v(" "),a("blockquote",[a("p",[t._v("理论总是作为实践指导的工具，把这些知识应用到实际工作中才是我们的最终目的。")])]),t._v(" "),a("p",[t._v("工具永远是知识技能的一层包装，没有什么工具是“秘密武器”，拥有了就能“包治百病”。")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_1_tuning_introd.html"}},[t._v("概述")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_2_tuning_command.html"}},[t._v("JVM监控及诊断工具-命令行篇")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_3_tuning_gui.html"}},[t._v("JVM监控及诊断工具-GUI篇")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_4_tuning_vmparam.html"}},[t._v("JVM运行时参数")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/1_17_gc_log.html"}},[t._v("GC日志分析")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_6_tuning_heap_shallow_retained.html"}},[t._v("浅堆深堆与支配树")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_8_tuning_heap_leak_overflow.html"}},[t._v("内存泄漏与内存溢出")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_7_tuning_qql.html"}},[t._v("QQL语言查询对象信息")])],1)]),t._v(" "),a("h2",{attrs:{id:"监控与调优案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控与调优案例"}},[t._v("#")]),t._v(" 监控与调优案例")]),t._v(" "),a("blockquote",[a("p",[t._v("除了知识与工具外，经验同样是一个很重要的因素。")])]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case0_introd.html"}},[t._v("概述")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case0_tomcat_hoom.html"}},[t._v("Tomcat堆溢出分析")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case1_heap_oom.html"}},[t._v("堆溢出")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case2_method_oom.html"}},[t._v("方法区溢出")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case3_limit_exceeded.html"}},[t._v("GC overhead limit exceeded")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_case4_thread_oom.html"}},[t._v("线程溢出")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case1_tps.html"}},[t._v("调整堆大小提高服务的吞吐量")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case2_jit.html"}},[t._v("JVM优化之JIT优化")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case3_heapsize.html"}},[t._v("合理配置堆内存")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case4_cpu_hight.html"}},[t._v("CPU占用很高排查方案")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case5_g1.html"}},[t._v("G1并发执行的线程数对性能的影响")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case6_gcc.html"}},[t._v("调整垃圾回收器提高服务的吞吐量")])],1),t._v(" "),a("li",[a("RouterLink",{attrs:{to:"/java-vm/3_tuning_perf_case7_millions4orders.html"}},[t._v("日均百万级订单交易系统如何设置JVM参数")])],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);