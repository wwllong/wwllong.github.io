(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{837:function(t,_,a){"use strict";a.r(_);var e=a(58),v=Object(e.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浅堆深堆与支配树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅堆深堆与支配树"}},[t._v("#")]),t._v(" 浅堆深堆与支配树")]),t._v(" "),a("p",[t._v("以下概念是在对Java堆进行监控以及诊断分析时会用到的，特别是MAT工具。")]),t._v(" "),a("h2",{attrs:{id:"浅堆-shallow-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅堆-shallow-heap"}},[t._v("#")]),t._v(" 浅堆（Shallow Heap）")]),t._v(" "),a("p",[t._v("浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。")]),t._v(" "),a("p",[t._v("以"),a("code",[t._v("String")]),t._v("为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。（JDK 7中）")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("int")]),t._v(" "),a("th",[t._v("hash32")]),t._v(" "),a("th",[t._v("0")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("int")])]),t._v(" "),a("td",[a("strong",[t._v("hash")])]),t._v(" "),a("td",[a("strong",[t._v("0")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("ref")])]),t._v(" "),a("td",[a("strong",[t._v("value")])]),t._v(" "),a("td",[a("strong",[t._v("C:\\Users\\Administrat")])])])])]),t._v(" "),a("p",[t._v("这24字节为"),a("code",[t._v("String")]),t._v("对象的浅堆大小。它与"),a("code",[t._v("String")]),t._v("的"),a("code",[t._v("value")]),t._v("实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。")]),t._v(" "),a("h2",{attrs:{id:"保留集-retained-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保留集-retained-set"}},[t._v("#")]),t._v(" 保留集（Retained Set）")]),t._v(" "),a("p",[t._v("对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是"),a("strong",[t._v("只能通过对象A被直接或间接访问到的所有对象的集合")]),t._v("。通俗地说，就是指仅被对象A所持有的对象的集合。")]),t._v(" "),a("h2",{attrs:{id:"深堆-retained-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深堆-retained-heap"}},[t._v("#")]),t._v(" 深堆（Retained Heap）")]),t._v(" "),a("p",[t._v("深堆是指对象的保留集中所有的对象的浅堆大小之和。")]),t._v(" "),a("p",[t._v("注意："),a("strong",[t._v("浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"对象的实际大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的实际大小"}},[t._v("#")]),t._v(" 对象的实际大小")]),t._v(" "),a("p",[t._v("这里，对象的实际大小定义为"),a("strong",[t._v("一个对象所能触及的所有对象的浅堆大小之和")]),t._v("，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，"),a("strong",[t._v("这个概念和垃圾回收无关")]),t._v("。")]),t._v(" "),a("p",[t._v("下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_heap_shallow_retained_1.png",alt:"tuning_heap_shallow_retained_1.png"}})]),t._v(" "),a("h2",{attrs:{id:"支配树-dominator-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#支配树-dominator-tree"}},[t._v("#")]),t._v(" 支配树（Dominator Tree）")]),t._v(" "),a("p",[t._v("支配树的概念源自图论。MAT提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：")]),t._v(" "),a("ul",[a("li",[t._v("对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。")]),t._v(" "),a("li",[t._v("如果对象A支配对象B，那么对象A的直接支配者也支配对象B。")]),t._v(" "),a("li",[t._v("支配树的边与对象引用图的边不直接对应。")])]),t._v(" "),a("p",[t._v("如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/tuning/tuning_heap_shallow_retained_2.png",alt:"tuning_heap_shallow_retained_2.png"}})])])}),[],!1,null,null,null);_.default=v.exports}}]);