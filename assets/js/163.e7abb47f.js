(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{811:function(v,_,t){"use strict";t.r(_);var a=t(58),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"垃圾回收概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收概述"}},[v._v("#")]),v._v(" 垃圾回收概述")]),v._v(" "),t("p",[v._v("Java与C++之间有一堵动态分配和垃圾收集技术所围成的高墙，墙外的人想进去，墙里面的人想出来。")]),v._v(" "),t("p",[v._v("除了内存区的划分外，垃圾收集器技术也是面试常考的知识点。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/foreword_3.png",alt:"foreword_3"}})]),v._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。")]),v._v(" "),t("p",[v._v("关于垃圾收集有三个经典问题：")]),v._v(" "),t("ul",[t("li",[v._v("哪些内存需要回收？")]),v._v(" "),t("li",[v._v("什么时候回收？")]),v._v(" "),t("li",[v._v("如何回收？")])]),v._v(" "),t("p",[v._v("垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点（可见附录）。")]),v._v(" "),t("h2",{attrs:{id:"什么是垃圾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾"}},[v._v("#")]),v._v(" 什么是垃圾")]),v._v(" "),t("p",[v._v("垃圾是指"),t("strong",[v._v("在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾")]),v._v("。")]),v._v(" "),t("p",[v._v("如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致"),t("strong",[v._v("内存溢出")]),v._v("。")]),v._v(" "),t("p",[v._v("PS：垃圾回收旧类似于我们对机械硬盘需要进行磁盘整理。")]),v._v(" "),t("h2",{attrs:{id:"为什么需要gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要gc"}},[v._v("#")]),v._v(" 为什么需要GC")]),v._v(" "),t("p",[v._v("想要学习GC，首先需要理解为什么需要GC？")]),v._v(" "),t("p",[v._v("对于高级语言来说，一个基本认知是"),t("strong",[v._v("如果不进行垃圾回收，内存迟早都会被消耗完")]),v._v("，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。")]),v._v(" "),t("p",[v._v("除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。"),t("strong",[v._v("碎片整理")]),v._v("将所占用的堆内存移到堆的一端，以便"),t("strong",[v._v("JVM将整理出的内存分配给新的对象")]),v._v("。")]),v._v(" "),t("p",[v._v("随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能"),t("strong",[v._v("保证应用程序的正常、高效得运行")]),v._v("。而经常造成"),t("code",[v._v("STW")]),v._v("（Stop The World）的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。")]),v._v(" "),t("h2",{attrs:{id:"早期垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#早期垃圾回收"}},[v._v("#")]),v._v(" 早期垃圾回收")]),v._v(" "),t("p",[v._v("在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用"),t("code",[v._v("new")]),v._v("关键字进行内存申请，并使用"),t("code",[v._v("delete")]),v._v("关键字进行内存释放，比如以下代码：")]),v._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("MibBridge *pBridge= new cmBaseGroupBridge();\n// 如果注册失败，使用Delete释放该对象所占内存区域\nif (pBridge->Register(kDestroy) != NO ERROR）\n\tdelete pBridge;\n")])])]),t("p",[v._v("这种方式可以灵活控制内存释放的时间，但是会给开发人员带来"),t("strong",[v._v("频繁申请和释放内存的管理负担")]),v._v("。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生"),t("strong",[v._v("内存泄漏")]),v._v("，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现"),t("strong",[v._v("内存溢出")]),v._v("并造成应用程序崩溃。")]),v._v(" "),t("p",[v._v("在有了垃圾回收机制后，上述代码极有可能变成这样:")]),v._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("MibBridge *pBridge = new cmBaseGroupBridge(); \npBridge->Register(kDestroy);\n")])])]),t("p",[v._v("现在，除了"),t("code",[v._v("Java")]),v._v("以外，"),t("code",[v._v("C#")]),v._v("、"),t("code",[v._v("Python")]),v._v("、"),t("code",[v._v("Ruby")]),v._v(" 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种"),t("strong",[v._v("自动化的内存分配和垃圾回收方式已经成为了现代开发语言必备的标准")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"java垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java垃圾回收机制"}},[v._v("#")]),v._v(" Java垃圾回收机制")]),v._v(" "),t("p",[v._v("自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险。如果没有垃圾回收器，"),t("code",[v._v("Java")]),v._v("也会和"),t("code",[v._v("c++")]),v._v("一样，各种悬垂指针，野指针，泄露等问题让你头疼不已。")]),v._v(" "),t("p",[v._v("自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地"),t("strong",[v._v("专注于业务开发")]),v._v("。")]),v._v(" "),t("blockquote",[t("p",[t("code",[v._v("Oracle")]),v._v("官网关于"),t("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("垃圾回收的介绍"),t("OutboundLink")],1)])]),v._v(" "),t("h3",{attrs:{id:"担忧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#担忧"}},[v._v("#")]),v._v(" 担忧")]),v._v(" "),t("p",[v._v("对于"),t("code",[v._v("Java")]),v._v("开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会"),t("strong",[v._v("弱化"),t("code",[v._v("Java")]),v._v("开发人员在程序出现内存溢出时定位问题和解决问题的能力")]),v._v("。")]),v._v(" "),t("p",[v._v("此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见"),t("code",[v._v("OutofMemoryError")]),v._v("时，快速地根据错误异常日志定位问题和解决问题。")]),v._v(" "),t("p",[v._v("当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须"),t("strong",[v._v("对这些“自动化”的技术实施必要的监控和调节")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"gc主要关注的区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc主要关注的区域"}},[v._v("#")]),v._v(" GC主要关注的区域")]),v._v(" "),t("p",[v._v("垃圾收集器可以对运行时数据区的方法区、堆进行GC，其中"),t("strong",[v._v("Java堆是垃圾收集器的工作重点")]),v._v("，详细来说就包括年轻代、老年代、方法区的回收。")]),v._v(" "),t("p",[v._v("从次数上讲：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("频繁收集Young区")])]),v._v(" "),t("li",[t("strong",[v._v("较少收集Old区")])]),v._v(" "),t("li",[t("strong",[v._v("基本不收集Perm区（元空间）")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://qiniu.wenwl.site/notes/jvm/gc_introd_1.png",alt:"gc_introd_1"}})]),v._v(" "),t("h2",{attrs:{id:"附-大厂面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#附-大厂面试题"}},[v._v("#")]),v._v(" 附：大厂面试题")]),v._v(" "),t("ol",[t("li",[v._v("蚂蚁金服")])]),v._v(" "),t("ul",[t("li",[v._v("你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？")]),v._v(" "),t("li",[v._v("JVM GC算法有哪些，目前的JDK版本采用什么回收算法？")]),v._v(" "),t("li",[v._v("G1回收器讲下回收过程GC是什么？为什么要有GC？")]),v._v(" "),t("li",[v._v("GC的两种判定方法？CMS收集器与G1收集器的特点")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("百度")])]),v._v(" "),t("ul",[t("li",[v._v("说一下GC算法，分代回收说下")]),v._v(" "),t("li",[v._v("垃圾收集策略和算法")])]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("天猫")])]),v._v(" "),t("ul",[t("li",[v._v("JVM GC原理，JVM怎么回收内存")]),v._v(" "),t("li",[v._v("CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？")])]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[v._v("滴滴")])]),v._v(" "),t("ul",[t("li",[v._v("Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的")])]),v._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[v._v("京东")])]),v._v(" "),t("ul",[t("li",[v._v("你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。")]),v._v(" "),t("li",[v._v("垃圾回收算法的实现原理")])]),v._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[v._v("阿里")])]),v._v(" "),t("ul",[t("li",[v._v("讲一讲垃圾回收算法。")]),v._v(" "),t("li",[v._v("什么情况下触发垃圾回收？")]),v._v(" "),t("li",[v._v("如何选择合适的垃圾收集算法？")]),v._v(" "),t("li",[v._v("JVM有哪三种垃圾回收器？")])]),v._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[v._v("字节跳动")])]),v._v(" "),t("ul",[t("li",[v._v("常见的垃圾回收器算法有哪些，各有什么优劣？")]),v._v(" "),t("li",[v._v("System.gc（）和Runtime.gc（）会做什么事情？")]),v._v(" "),t("li",[v._v("Java GC机制？GC Roots有哪些？")]),v._v(" "),t("li",[v._v("Java对象的回收方式，回收算法。")]),v._v(" "),t("li",[v._v("CMS和G1了解么，CMS解决什么问题，说一下回收的过程。")]),v._v(" "),t("li",[v._v("CMS回收停顿了几次，为什么要停顿两次?")])])])}),[],!1,null,null,null);_.default=r.exports}}]);